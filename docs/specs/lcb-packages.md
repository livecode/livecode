# LiveCode Builder Packages
Copyright 2015 LiveCode Ltd.

## Introduction

LiveCode Builder is built around the idea of 'modules' - independently compiled
units of code which can be selectively used by others.

In a larger system, however, just the compiled module code is not enough. There
are other things which are naturally related to the module which don't make sense
to be included within the modules binary file - principally because they are not
of direct interest to the virtual machine which must execute the code.

To solve this problem, compiled LCB modules are embedded in a more general
container called a 'package'. A package is a ZIP format archive file with a
standard structure which combines modules together with other related resources
and metadata which can be used by an environment loading it.

## Structure

An LCB package is a ZIP archive with a standard layout:

    <root>/
        mimetype
        manifest.xml
        module.lcm (current)
        modules/
            <compiled module code> (revised)
        code/
            mac-x86_64-10_6/
                <compiled foreign code for 64-bit Mac min version 10.6>
            iossimulator-i386-4_3/
                <compiled foreign code for 32-bit iOS Simulator min version 4.3>
            windows-i386/
                <compiled foreign code for 32-bit windows>
            <arch>/
                ...
        resources/
            <resource files for compiled modules>
        source/
            <source files for compiled modules>
        support/
            <structure defined by loading environment>
        docs/
            <structure defined by loading environment>
      
The support, docs and manifest file are not used by the LCB runtime itself and
provide supporting information for the environment that is intended to load and
use the package.

Note: At present a package only ever contains a single compiled module which is
placed as <root>/module.lcm. The revised package format will see all modules
within the modules subfolder.

## Contents

### Mimetype (pending)

This file has a single line of text which gives the MIME type for the document.
It must be the first file included in the zip archive and be stored in an
uncompressed form. This ensures that 'magic number' mechanisms can be used to
determine the actual type of the package file.

### Manifest (current)
The manifest.xml file is generated by the compiler when it compiles a module.
This file replicates most of the information present in the binary module file,
but in a way the loading environment can access directly without having to load
the module.

The outline of the manifest file format is as follows:

    <package version="1.0">
        <label>Human Readable Foo</label>
        <author>Mr Magoo</author>
        <description>Foo is a super amazing widget that will do everything for you.</description>
        <license>commercial|dual|community</license>
        <name>com.livecode.foo</name>
        <version>X.Y.Z</version>
        <type>widget|library</type>
        <requires name="com.livecode.bar" version="X.Y.Z" />
        <requires name="com.livecode.baz" version="X.Y.Z" />
        <property name="foo" get="optional(integer)" set="optional(integer)" />
        <property name="bar" get="string" />
        <event name="click" parameters="in(integer),out(real)" return="optional(any)" />
        <handler name="magic" parameters="in(integer),inout(string)" return="undefined" />
    </package>

This format works where a package contains a single module, and that module is a
library or widget. However, it is not sufficient to describe a package which
exports multiple widgets or library exports.

### Manifest (revised)

TBD

### Modules (revised)

The modules folder contains all the compiled module code which the package contains.
The filenames of each module file must match the name of module contained within it
with a .lcb suffix.

A package is considered invalid if the package name is not a common strict prefix of
all the modules it contains.

For example, this is a valid package:

    com.example.foo.lcp/
        modules/
            com.example.foo.bar.lcb
            com.example.foo.bar.tests.lcb
            
This is an invalid package:

    com.example.foo.lcp/
        modules/
            com.example.foo.lcb
            org.example.foo.lcb

### Code (revised)

The code folder contains all the (non-system) foreign code components that are
needed by any compiled module 'foreign handler' definitions.

The folder is split up into sub-folders by architecture triples:

    <platform>-<arch>-<variant>
    
The platform field specifies the target platform. It can be one of the following:

    - mac
    - windows
    - linux
    - ios
    - ios_simulated
    - android
    
The arch field specifies what architecture the platform has been compiled for.
The supported values depend on the platform:

    - mac: i386, x86_64 (future)
    - windows: i386, x86_64 (future)
    - linux: i386, x86_64
    - ios: armv6, armv7, armv7s, arm64
    - ios_simulated: i386, x86_64
    - android: java, armv6, armv7 (future)

The variant field is optional and specifies per platform-arch specific variants.
For example, iOS can be compiled against differing C++ library versions and
target different minimum OS versions which can affect the linkability of the
end products. (TBD)

For Mac, Windows and Linux the binary components should be provided as shared
libraries (.bundle or .dylib for Mac, .dll for Windows, .so for Linux). In the
future partially compiled object code might also be supported.

For iOS, the binary components should be provided as partially compiled object
code.

For iOS-Simulated, the binary components should be provided as shared libraries
(.dylib).

For Android, the native code binary components should be provided as shared
libraries (.so) whilst the Java 'native code' binary components should be
provided in dex format (.dex).

### Resources

### Support

### Source

### Docs

## Signing
