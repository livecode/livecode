# LiveCode Builder Packages
Copyright 2015 LiveCode Ltd.

## Introduction

LiveCode Builder is built around the idea of 'modules' - independently compiled
units of code which can be selectively used by others.

In a larger system, however, just the compiled module code is not enough. There
are other things which are naturally related to the module which don't make sense
to be included within the modules binary file - principally because they are not
of direct interest to the virtual machine which must execute the code.

To solve this problem, compiled LCB modules are embedded in a more general
container called a 'package'. A package is a ZIP format archive file with a
standard structure which combines modules together with other related resources
and metadata which can be used by an environment loading it.

## Structure

An LCB package is a ZIP archive with a standard layout:

    <root>/
        mimetype
        manifest.xml
        module.lcm (current)
        modules/
            <compiled module code> (revised)
        source/
            <source files for compiled modules>
        code/
            mac-x86_64-10_6/
                <compiled foreign code for 64-bit Mac min version 10.6>
            iossimulator-i386-4_3/
                <compiled foreign code for 32-bit iOS Simulator min version 4.3>
            windows-i386/
                <compiled foreign code for 32-bit windows>
            <arch>/
                ...
        resources/
            <resource files for compiled modules>
        support/
            <structure defined by loading environment>
        docs/
            <structure defined by loading environment>
      
The support, docs and manifest file are not used by the LCB runtime itself and
provide supporting information for the environment that is intended to load and
use the package.

Note: At present a package only ever contains a single compiled module which is
placed as <root>/module.lcm. The revised package format will see all modules
within the modules subfolder.

## Contents

### Mimetype (pending)

This file has a single line of text which gives the MIME type for the document.
It must be the first file included in the zip archive and be stored in an
uncompressed form. This ensures that 'magic number' mechanisms can be used to
determine the actual type of the package file.

### Manifest (current)
The manifest.xml file is generated by the compiler when it compiles a module.
This file replicates most of the information present in the binary module file,
but in a way the loading environment can access directly without having to load
the module.

The outline of the manifest file format is as follows:

    <package version="1.0">
        <label>Human Readable Foo</label>
        <author>Mr Magoo</author>
        <description>Foo is a super amazing widget that will do everything for you.</description>
        <license>commercial|dual|community</license>
        <name>com.livecode.foo</name>
        <version>X.Y.Z</version>
        <type>widget|library</type>
        <metadata key="mykey">myvalue</metadata>
        <requires name="com.livecode.bar" version="X.Y.Z" />
        <requires name="com.livecode.baz" version="X.Y.Z" />
        <property name="foo" get="optional(integer)" set="optional(integer)" />
        <property name="bar" get="string" />
        <event name="click" parameters="in(integer),out(real)" return="optional(any)" />
        <handler name="magic" parameters="in(integer),inout(string)" return="undefined" />
    </package>

This format works where a package contains a single module, and that module is a
library or widget. However, it is not sufficient to describe a package which
exports multiple widgets or library exports.

### Manifest (revised)

TBD

### Modules (revised)

The modules folder contains all the compiled module code which the package contains.
The filenames of each module file must match the name of module contained within it
with a .lcb suffix.

A package is considered invalid if the package name is not a common strict prefix of
all the modules it contains.

For example, this is a valid package:

    com.example.foo.lcp/
        modules/
            com.example.foo.bar.lcb
            com.example.foo.bar.tests.lcb
            
This is an invalid package:

    com.example.foo.lcp/
        modules/
            com.example.foo.lcb
            org.example.foo.lcb

### Source

The source folder contains the original source files which were used to build the
compiled modules contained within the modules folder. The original folder structure
of the source will be preserved as much as possible, with the debug annotations
within the compiled modules themselves referencing files relative to <package>/source.

### Code (revised)

The code folder contains all the (non-system) foreign code components that are
needed by any compiled module 'foreign handler' definitions.

The folder is split up into sub-folders by architecture triples:

    <platform>-<arch>-<variant>
    
The platform field specifies the target platform. It can be one of the following:

    - mac
    - windows
    - linux
    - ios
    - ios_simulated
    - android
    
The arch field specifies what architecture the platform has been compiled for.
The supported values depend on the platform:

    - mac: i386, x86_64 (future)
    - windows: i386, x86_64 (future)
    - linux: i386, x86_64
    - ios: armv6, armv7, armv7s, arm64
    - ios_simulated: i386, x86_64
    - android: java, armv6, armv7 (future)

The variant field is optional and specifies per platform-arch specific variants.
For example, iOS can be compiled against differing C++ library versions and
target different minimum OS versions which can affect the linkability of the
end products. (TBD)

For Mac, Windows and Linux the binary components should be provided as shared
libraries (.bundle or .dylib for Mac, .dll for Windows, .so for Linux). In the
future partially compiled object code might also be supported.

For iOS, the binary components should be provided as partially compiled object
code.

For iOS-Simulated, the binary components should be provided as shared libraries
(.dylib).

For Android, the native code binary components should be provided as shared
libraries (.so) whilst the Java 'native code' binary components should be
provided in dex format (.dex).

### Resources

The resources folder is a file hierarchy defined by the package author. It
provides a private collection of resources which can (notionally) only be
accessed by modules from within the package.

Explicit syntax in LCB provides access to such resource files using absolute
filenames which are resolved relative to <package>/resources/.

### Support

The contents of the support folder is defined by the environment that will be
using the package.

### Docs

The contents of the docs folder is defined by the environment that will be
using the package.

## Signing

In order to establish some level of trust between package consumers and package
providers a method of signing a package is required.

There are two types of signing which can be performed on a package.

The first signs a hash generated from the whole package file, appending the
signature to the archive in a way which does not prevent usage of the archive
as a ZIP.

The second signs per-file hashes of each file within the package. The signature
is stored in a META-INF folder within the zip archive alongside a manifest which
describes the hashes of each file.

### Whole-file Signatures

[This method of whole-file signing is taken from Android APK OTA signing as
described here http://nelenkov.blogspot.co.uk/2013/04/android-code-signing.html]

A DER encoded PKCS#7 signature using SHA256 digest algorithm is generated for all
the bytes in the archive up to, but not including the final comment length and
comment field in the ZIP archive.

The resulting sequence of bytes is placed in the comment field in the following
layout:

    char[] message;
    uint8_t terminator;
    uint8_t[] signature;
    uint16_t offset_to_signature;
    uint8_t pad0;
    uint8_t pad1;
    uint16_t comment_length;
    
The message is a string which ZIP tools might display if they extract the comment.
It currently says "signed by LiveCode".
    
The terminator is always the NUL byte (hopefully meaning ZIP tools will only see
'signed by LiveCode' in the comment).

The sigature is the encoded PKCS#7 signature.

The offset_to_signature is the offset from the end of the file to the start of
the signature data.

The pad0, pad1 fields are always 0xFF. This helps check whether the input file
is a commentless archive, or a previously whole-file signed ZIP.

The comment_length is the total length of the comment field.

### Per-file Signatures

TBD
