/* Copyright (C) 2003-2015 LiveCode Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

#include "prefix.h"

////////////////////////////////////////////////////////////////////////////////

bool MCUnicodeMapToNativeSingleton_Windows1252(uint4 x, uint1& r_char)
{
	static const uint4 s_singletons[] =
	{
		0x8c000152, 0x9c000153, 0x8a000160, 0x9a000161, 0x9f000178, 0x8e00017d,
		0x9e00017e, 0x83000192, 0x880002c6, 0x980002dc, 0x96002013, 0x97002014,
		0x91002018, 0x92002019, 0x8200201a, 0x9300201c, 0x9400201d, 0x8400201e,
		0x86002020, 0x87002021, 0x95002022, 0x85002026, 0x89002030, 0x8b002039,
		0x9b00203a, 0x800020ac, 0x99002122
	};

	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_singletons) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_singleton;
		t_singleton = s_singletons[t_mid] & 0xffffff;

		if (x < t_singleton)
			t_high = t_mid;
		else if (x > t_singleton)
			t_low = t_mid + 1;
		else
		{
			r_char = s_singletons[t_mid] >> 24;
			return true;
		}
	}

	return false;
}

bool MCUnicodeMapToNativeSingleton_MacRoman(uint4 x, uint1& r_char)
{
	static const uint4 s_singletons[] =
	{
		0xca0000a0, 0xc10000a1, 0xa20000a2, 0xa30000a3, 0xb40000a5, 0xa40000a7, 
		0xac0000a8, 0xa90000a9, 0xbb0000aa, 0xc70000ab, 0xc20000ac, 0xa80000ae, 
		0xf80000af, 0xa10000b0, 0xb10000b1, 0xab0000b4, 0xb50000b5, 0xa60000b6, 
		0xe10000b7, 0xfc0000b8, 0xbc0000ba, 0xc80000bb, 0xc00000bf, 0xcb0000c0, 
		0xe70000c1, 0xe50000c2, 0xcc0000c3, 0x800000c4, 0x810000c5, 0xae0000c6, 
		0x820000c7, 0xe90000c8, 0x830000c9, 0xe60000ca, 0xe80000cb, 0xed0000cc, 
		0xea0000cd, 0xeb0000ce, 0xec0000cf, 0x840000d1, 0xf10000d2, 0xee0000d3, 
		0xef0000d4, 0xcd0000d5, 0x850000d6, 0xaf0000d8, 0xf40000d9, 0xf20000da, 
		0xf30000db, 0x860000dc, 0xa70000df, 0x880000e0, 0x870000e1, 0x890000e2, 
		0x8b0000e3, 0x8a0000e4, 0x8c0000e5, 0xbe0000e6, 0x8d0000e7, 0x8f0000e8, 
		0x8e0000e9, 0x900000ea, 0x910000eb, 0x930000ec, 0x920000ed, 0x940000ee, 
		0x950000ef, 0x960000f1, 0x980000f2, 0x970000f3, 0x990000f4, 0x9b0000f5, 
		0x9a0000f6, 0xd60000f7, 0xbf0000f8, 0x9d0000f9, 0x9c0000fa, 0x9e0000fb, 
		0x9f0000fc, 0xd80000ff, 0xf5000131, 0xce000152, 0xcf000153, 0xd9000178, 
		0xc4000192, 0xf60002c6, 0xff0002c7, 0xf90002d8, 0xfa0002d9, 0xfb0002da, 
		0xfe0002db, 0xf70002dc, 0xfd0002dd, 0xbd0003a9, 0xb90003c0, 0xd0002013, 
		0xd1002014, 0xd4002018, 0xd5002019, 0xe200201a, 0xd200201c, 0xd300201d, 
		0xe300201e, 0xa0002020, 0xe0002021, 0xa5002022, 0xc9002026, 0xe4002030, 
		0xdc002039, 0xdd00203a, 0xda002044, 0xdb0020ac, 0xaa002122, 0xb6002202, 
		0xc6002206, 0xb800220f, 0xb7002211, 0xc300221a, 0xb000221e, 0xba00222b, 
		0xc5002248, 0xad002260, 0xb2002264, 0xb3002265, 0xd70025ca, 0xf000f8ff, 
		0xde00fb01, 0xdf00fb02
	};
	
	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_singletons) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_singleton;
		t_singleton = s_singletons[t_mid] & 0xffffff;
		
		if (x < t_singleton)
			t_high = t_mid;
		else if (x > t_singleton)
			t_low = t_mid + 1;
		else
		{
			r_char = s_singletons[t_mid] >> 24;
			return true;
		}
	}
	
	return false;
}

bool MCUnicodeMapToNativeSingleton_ISO8859_1(uint4 x, uint1& r_char)
{
	static const uint4 s_singletons[] =
	{
		0xa50000a5,
		0xa70000a7,
		0xa90000a9,
		0xaa0000aa,
		0xab0000ab,
		0xac0000ac,
		0xad0000ad,
		0xae0000ae,
		0xaf0000af,
		0xb00000b0,
		0xb10000b1,
		0xb20000b2,
		0xb30000b3,
		0xb50000b5,
		0xb60000b6,
		0xb70000b7,
		0xb90000b9,
		0xba0000ba,
		0xbb0000bb,
		0xbc000152,
		0xbd000153,
		0xa6000160,
		0xa8000161,
		0xbe000178,
		0xb400017d,
		0xb800017e, 
		0xa40020ac
	};
	
	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_singletons) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_singleton;
		t_singleton = s_singletons[t_mid] & 0xffffff;
		
		if (x < t_singleton)
			t_high = t_mid;
		else if (x > t_singleton)
			t_low = t_mid + 1;
		else
		{
			r_char = s_singletons[t_mid] >> 24;
			return true;
		}
	}
	
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool MCUnicodeMapToNativePair_Windows1252(uint4 x, uint4 y, uint1& r_char)
{
	static const uint4 s_pairs[] =
	{
	/* A */ 0xC0410300, 0xC1410301, 0xC2410302, 0xC3410303, 0xC4410308, 0xC541030A,
	/* C */ 0xC7430327,
	/* E */ 0xC8450300, 0xC9450301, 0xCA450302, 0xCB450308,
	/* I */ 0xCC490300, 0xCD490301, 0xCE490302, 0xCF490308,
	/* N */ 0xD14E0303,
	/* O */ 0xD24F0300, 0xD34F0301, 0xD44F0302, 0xD54F0303, 0xD64F0308, 
	/* U */ 0xD9550300, 0xDA550301, 0xDB550302, 0xDC550308,
	/* S */ 0x8A53030C,
	/* Y */ 0xDD590301, 0x9F590308,
	/* Z */ 0x8E5A030C,

	/* a */ 0xE0610300, 0xE1610301, 0xE2610302, 0xE3610303, 0xE4610308, 0xE561030A,
	/* c */ 0xE7630327,
	/* e */ 0xE8650300, 0xE9650301, 0xEA650302, 0xEB650308,
	/* i */ 0xEC690300, 0xED690301, 0xEE690302, 0xEF690308,
	/* n */ 0xF16E0303,
	/* i */ 0xF26F0300, 0xF36F0301, 0xF46F0302, 0xF56F0303, 0xF66F0308, 
	/* u */ 0xF9750300, 0xFA750301, 0xFB750302, 0xFC750308,
	/* s */ 0x9A73030C,
	/* y */ 0xFD790301, 0xFF790308,
	/* z */ 0x9E7A030C
	};

	uint4 z;
	z = (x << 16) | y;

	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_pairs) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_singleton;
		t_singleton = s_pairs[t_mid] & 0xffffff;

		if (z < t_singleton)
			t_high = t_mid;
		else if (z > t_singleton)
			t_low = t_mid + 1;
		else
		{
			r_char = s_pairs[t_mid] >> 24;
			return true;
		}
	}

	return false;
}

bool MCUnicodeMapToNativePair_MacRoman(uint4 x, uint4 y, uint1& r_char)
{
	static const uint4 s_pairs[] =
	{
		0xAD3D0338,0xCB410300,0xE7410301,0xE5410302,0xCC410303,0x80410308,
		0x8141030A,0x82430327,0xE9450300,0x83450301,0xE6450302,0xE8450308,
		0xED490300,0xEA490301,0xEB490302,0xEC490308,0x844E0303,0xF14F0300,
		0xEE4F0301,0xEF4F0302,0xCD4F0303,0x854F0308,0xF4550300,0xF2550301,
		0xF3550302,0x86550308,0xD9590308,0x88610300,0x87610301,0x89610302,
		0x8B610303,0x8A610308,0x8C61030A,0x8D630327,0x8F650300,0x8E650301,
		0x90650302,0x91650308,0x93690300,0x92690301,0x94690302,0x95690308,
		0x966E0303,0x986F0300,0x976F0301,0x996F0302,0x9B6F0303,0x9A6F0308,
		0x9D750300,0x9C750301,0x9E750302,0x9F750308,0xD8790308
	};
	
	uint4 z;
	z = (x << 16) | y;
	
	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_pairs) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_singleton;
		t_singleton = s_pairs[t_mid] & 0xffffff;
		
		if (z < t_singleton)
			t_high = t_mid;
		else if (z > t_singleton)
			t_low = t_mid + 1;
		else
		{
			r_char = s_pairs[t_mid] >> 24;
			return true;
		}
	}
	
	return false;
}

bool MCUnicodeMapToNativePair_ISO8859_1(uint4 x, uint4 y, uint1& r_char)
{
	static const uint4 s_pairs[] =
	{
		/* S */ 0xA653030C,
		/* Y */ 0xBE590308,
		/* Z */ 0x8E5A030C,
		/* s */ 0xA873030C,
		/* z */ 0xB87A030C
	};
	
	uint4 z;
	z = (x << 16) | y;
	
	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_pairs) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_singleton;
		t_singleton = s_pairs[t_mid] & 0xffffff;
		
		if (z < t_singleton)
			t_high = t_mid;
		else if (z > t_singleton)
			t_low = t_mid + 1;
		else
		{
			r_char = s_pairs[t_mid] >> 24;
			return true;
		}
	}
	
	return false;
}

////////////////////////////////////////////////////////////////////////////////

uint4 MCUnicodeMapFromNativeSingleton_Windows1252(unsigned char p_char)
{
	static const uint2 s_mapping[] =
	{
		0x20ac, 0x0081, 0x201a, 0x0192, 0x201e, 0x2026, 0x2020, 0x2021, 0x02c6, 0x2030, 0x0160, 0x2039, 
		0x0152, 0x008d, 0x017d, 0x008f, 0x0090, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 
		0x02dc, 0x2122, 0x0161, 0x203a, 0x0153, 0x009d, 0x017e, 0x0178
	};
	return s_mapping[p_char - 0x80];
}

uint4 MCUnicodeMapFromNativeSingleton_MacRoman(unsigned char p_char)
{
	static const uint2 s_mapping[] =
	{
		0x00c4, 0x00c5, 0x00c7, 0x00c9, 0x00d1, 0x00d6, 0x00dc, 0x00e1, 0x00e0, 0x00e2, 0x00e4, 0x00e3, 
		0x00e5, 0x00e7, 0x00e9, 0x00e8, 0x00ea, 0x00eb, 0x00ed, 0x00ec, 0x00ee, 0x00ef, 0x00f1, 0x00f3, 
		0x00f2, 0x00f4, 0x00f6, 0x00f5, 0x00fa, 0x00f9, 0x00fb, 0x00fc, 0x2020, 0x00b0, 0x00a2, 0x00a3, 
		0x00a7, 0x2022, 0x00b6, 0x00df, 0x00ae, 0x00a9, 0x2122, 0x00b4, 0x00a8, 0x2260, 0x00c6, 0x00d8, 
		0x221e, 0x00b1, 0x2264, 0x2265, 0x00a5, 0x00b5, 0x2202, 0x2211, 0x220f, 0x03c0, 0x222b, 0x00aa, 
		0x00ba, 0x03a9, 0x00e6, 0x00f8, 0x00bf, 0x00a1, 0x00ac, 0x221a, 0x0192, 0x2248, 0x2206, 0x00ab, 
		0x00bb, 0x2026, 0x00a0, 0x00c0, 0x00c3, 0x00d5, 0x0152, 0x0153, 0x2013, 0x2014, 0x201c, 0x201d, 
		0x2018, 0x2019, 0x00f7, 0x25ca, 0x00ff, 0x0178, 0x2044, 0x20ac, 0x2039, 0x203a, 0xfb01, 0xfb02, 
		0x2021, 0x00b7, 0x201a, 0x201e, 0x2030, 0x00c2, 0x00ca, 0x00c1, 0x00cb, 0x00c8, 0x00cd, 0x00ce, 
		0x00cf, 0x00cc, 0x00d3, 0x00d4, 0xf8ff, 0x00d2, 0x00da, 0x00db, 0x00d9, 0x0131, 0x02c6, 0x02dc, 
		0x00af, 0x02d8, 0x02d9, 0x02da, 0x00b8, 0x02dd, 0x02db, 0x02c7 
	};
	return s_mapping[p_char - 0x80];
}

uint4 MCUnicodeMapFromNativeSingleton_ISO8859_1(unsigned char p_char)
{
	// There are no native singleton special cases for ISO8859-1.
	return 0;
}

////////////////////////////////////////////////////////////////////////////////

bool MCUnicodeCodepointIsCombiner(uint4 x)
{
	static const uint4 s_combiners[] =
	{
		0x4f000300, 0x20000350, 0x04000483, 0x2d000591, 0x010005bf, 0x020005c1,
		0x020005c4, 0x010005c7, 0x06000610, 0x1400064b, 0x01000670, 0x070006d6,
		0x060006df, 0x020006e7, 0x040006ea, 0x01000711, 0x1b000730, 0x090007eb,
		0x0100093c, 0x0100094d, 0x04000951, 0x010009bc, 0x010009cd, 0x01000a3c,
		0x01000a4d, 0x01000abc, 0x01000acd, 0x01000b3c, 0x01000b4d, 0x01000bcd,
		0x01000c4d, 0x02000c55, 0x01000cbc, 0x01000ccd, 0x01000d4d, 0x01000dca,
		0x03000e38, 0x04000e48, 0x02000eb8, 0x04000ec8, 0x02000f18, 0x01000f35,
		0x01000f37, 0x01000f39, 0x02000f71, 0x01000f74, 0x04000f7a, 0x01000f80,
		0x03000f82, 0x02000f86, 0x01000fc6, 0x01001037, 0x01001039, 0x0100135f,
		0x01001714, 0x01001734, 0x010017d2, 0x010017dd, 0x010018a9, 0x03001939,
		0x02001a17, 0x01001b34, 0x01001b44, 0x09001b6b, 0x0b001dc0, 0x02001dfe,
		0x0d0020d0, 0x010020e1, 0x0b0020e5, 0x0600302a, 0x02003099, 0x0100a806,
		0x0100fb1e, 0x0400fe20, 0x01010a0d, 0x01010a0f, 0x03010a38, 0x01010a3f,
		0x0501d165, 0x0601d16d, 0x0801d17b, 0x0701d185, 0x0401d1aa, 0x0301d242
	};
	
	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_combiners) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_start, t_finish;
		t_start = s_combiners[t_mid] & 0xffffff;
		t_finish = t_start + (s_combiners[t_mid] >> 24);
		
		if (x < t_start)
			t_high = t_mid;
		else if (x > t_finish)
			t_low = t_mid + 1;
		else
			return true;
	}
	
	return false;
}

bool MCUnicodeCodepointIsIdeographicLookup(uint4 x)
{
	static const uint4 s_ideographs[] =
	{
	  0x0e010e3a, 0x0e400e4e, 0x0e810e82, 0x0e840e84, 0x0e870e88, 0x0e8a0e8a, 0x0e8d0e8d, 0x0e940e97, 
	  0x0e990e9f, 0x0ea10ea3, 0x0ea50ea5, 0x0ea70ea7, 0x0eaa0eab, 0x0ead0eb9, 0x0ebb0ebd, 0x0ec00ec4, 
	  0x0ec60ec6, 0x0ec80ecd, 0x0edc0edd, 0x10001021, 0x10231027, 0x1029102a, 0x102c1032, 0x10361039, 
	  0x10501059, 0x11001159, 0x115f11a2, 0x11a811f9, 0x178017d3, 0x17d717d7, 0x17dc17dd, 0x1950196d, 
	  0x19701974, 0x198019a9, 0x19b019c9, 0x19de19df, 0x2e802e99, 0x2e9b2ef3, 0x2f002fd5, 0x2ff02ffb, 
	  0x30003000, 0x30033004, 0x30063007, 0x30123013, 0x30203029, 0x3030303a, 0x303d303f, 0x30423042, 
	  0x30443044, 0x30463046, 0x30483048, 0x304a3062, 0x30643082, 0x30843084, 0x30863086, 0x3088308d, 
	  0x308f3094, 0x309f309f, 0x30a230a2, 0x30a430a4, 0x30a630a6, 0x30a830a8, 0x30aa30c2, 0x30c430e2, 
	  0x30e430e4, 0x30e630e6, 0x30e830ed, 0x30ef30f4, 0x30f730fa, 0x30ff30ff, 0x3105312c, 0x3131318e, 
	  0x319031b7, 0x31c031cf, 0x3200321e, 0x32203243, 0x325032fe, 0x33004db5, 0x4e009fbb, 0xa000a014, 
	  0xa016a48c, 0xa490a4c6, 0xac00d7a3, 0xf900fa2d, 0xfa30fa6a, 0xfa70fad9, 0xfe30fe34, 0xfe45fe46, 
	  0xfe49fe4f, 0xfe51fe51, 0xfe58fe58, 0xfe5ffe66, 0xfe68fe68, 0xfe6bfe6b, 0xff02ff03, 0xff06ff07, 
	  0xff0aff0b, 0xff0dff0d, 0xff0fff19, 0xff1cff1e, 0xff20ff3a, 0xff3cff3c, 0xff3eff5a, 0xff5cff5c, 
	  0xff5eff5e, 0xffe2ffe4, 
	};
	
	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_ideographs) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_start, t_finish;
		t_start = s_ideographs[t_mid] >> 16;
		t_finish = s_ideographs[t_mid] & 0xffff;

		if (x < t_start)
			t_high = t_mid;
		else if (x > t_finish)
			t_low = t_mid + 1;
		else
			return true;
	}
	
	return false;
}

uint4 MCUnicodeCodepointGetBreakClass(uint4 x)
{
	static const uint4 s_break_classes[] =
	{
	  0x00000021, 0x000e0045, 0x00210001, 0x00220002, 0x00270006, 0x00290001, 0x003f0001, 0x005b0002, 
	  0x005d0001, 0x007b0002, 0x007d0001, 0x007f0015, 0x00860065, 0x00a00003, 0x00ab0002, 0x00bb0002, 
	  0x03000139, 0x034f0003, 0x0350002d, 0x035c001b, 0x03630031, 0x0483000d, 0x04880005, 0x059100b1, 
	  0x05bf0001, 0x05c10005, 0x05c4000d, 0x060c0001, 0x06100015, 0x061b0001, 0x061e0005, 0x064b004d, 
	  0x066a0001, 0x06700001, 0x06d40001, 0x06d60019, 0x06de0019, 0x06e70005, 0x06ea000d, 0x07110001, 
	  0x07300069, 0x07a60029, 0x07eb0021, 0x07f90001, 0x09010009, 0x093c0001, 0x093e003d, 0x0951000d, 
	  0x09620005, 0x09810009, 0x09bc0001, 0x09be0019, 0x09c70005, 0x09cb0009, 0x09d70001, 0x09e20005, 
	  0x0a010009, 0x0a3c0001, 0x0a3e0011, 0x0a470005, 0x0a4b0009, 0x0a700005, 0x0a810009, 0x0abc0001, 
	  0x0abe001d, 0x0ac70009, 0x0acb0009, 0x0ae20005, 0x0b010009, 0x0b3c0001, 0x0b3e0015, 0x0b470005, 
	  0x0b4b0009, 0x0b560005, 0x0b820001, 0x0bbe0011, 0x0bc60009, 0x0bca000d, 0x0bd70001, 0x0c010009, 
	  0x0c3e0019, 0x0c460009, 0x0c4a000d, 0x0c550005, 0x0c820005, 0x0cbc0001, 0x0cbe0019, 0x0cc60009, 
	  0x0cca000d, 0x0cd50005, 0x0ce20005, 0x0d020005, 0x0d3e0015, 0x0d460009, 0x0d4a000d, 0x0d570001, 
	  0x0d820005, 0x0dca0001, 0x0dcf0015, 0x0dd60001, 0x0dd8001d, 0x0df20005, 0x0f080003, 0x0f0c0003, 
	  0x0f0d0011, 0x0f120003, 0x0f140001, 0x0f180005, 0x0f350001, 0x0f370001, 0x0f390001, 0x0f3a0002, 
	  0x0f3b0001, 0x0f3c0002, 0x0f3d0009, 0x0f710035, 0x0f800011, 0x0f860005, 0x0f90001d, 0x0f99008d, 
	  0x0fc60001, 0x135f0001, 0x169b0002, 0x169c0001, 0x17120009, 0x17320009, 0x17520005, 0x17720005, 
	  0x180b0009, 0x180e0003, 0x18a90001, 0x1920002d, 0x1930002d, 0x19440005, 0x1a170011, 0x1b000011, 
	  0x1b340041, 0x1b6b0021, 0x1dc00029, 0x1dfe0005, 0x20070003, 0x200c000d, 0x20110003, 0x2018001e, 
	  0x202a0011, 0x202f0003, 0x20390006, 0x20450002, 0x20460001, 0x20600003, 0x206a0015, 0x207d0002, 
	  0x207e0001, 0x208d0002, 0x208e0001, 0x20d0007d, 0x23290002, 0x232a0001, 0x275b000e, 0x27620005, 
	  0x27680002, 0x27690001, 0x276a0002, 0x276b0001, 0x276c0002, 0x276d0001, 0x276e0002, 0x276f0001, 
	  0x27700002, 0x27710001, 0x27720002, 0x27730001, 0x27740002, 0x27750001, 0x27c50002, 0x27c60001, 
	  0x27e60002, 0x27e70001, 0x27e80002, 0x27e90001, 0x27ea0002, 0x27eb0001, 0x29830002, 0x29840001, 
	  0x29850002, 0x29860001, 0x29870002, 0x29880001, 0x29890002, 0x298a0001, 0x298b0002, 0x298c0001, 
	  0x298d0002, 0x298e0001, 0x298f0002, 0x29900001, 0x29910002, 0x29920001, 0x29930002, 0x29940001, 
	  0x29950002, 0x29960001, 0x29970002, 0x29980001, 0x29d80002, 0x29d90001, 0x29da0002, 0x29db0001, 
	  0x29fc0002, 0x29fd0001, 0x2e000036, 0x2e1c0006, 0x30010005, 0x30080002, 0x30090001, 0x300a0002, 
	  0x300b0001, 0x300c0002, 0x300d0001, 0x300e0002, 0x300f0001, 0x30100002, 0x30110001, 0x30140002, 
	  0x30150001, 0x30160002, 0x30170001, 0x30180002, 0x30190001, 0x301a0002, 0x301b0001, 0x301d0002, 
	  0x301e0005, 0x302a0015, 0x30990005, 0xa8020001, 0xa8060001, 0xa80b0001, 0xa8230011, 0xa8760005, 
	  0xfb1e0001, 0xfd3e0002, 0xfd3f0001, 0xfe00003d, 0xfe110005, 0xfe150005, 0xfe170002, 0xfe180001, 
	  0xfe20000d, 0xfe350002, 0xfe360001, 0xfe370002, 0xfe380001, 0xfe390002, 0xfe3a0001, 0xfe3b0002, 
	  0xfe3c0001, 0xfe3d0002, 0xfe3e0001, 0xfe3f0002, 0xfe400001, 0xfe410002, 0xfe420001, 0xfe430002, 
	  0xfe440001, 0xfe470002, 0xfe480001, 0xfe500001, 0xfe520001, 0xfe560005, 0xfe590002, 0xfe5a0001, 
	  0xfe5b0002, 0xfe5c0001, 0xfe5d0002, 0xfe5e0001, 0xfeff0003, 0xff010001, 0xff080002, 0xff090001, 
	  0xff0c0001, 0xff0e0001, 0xff1f0001, 0xff3b0002, 0xff3d0001, 0xff5b0002, 0xff5d0001, 0xff5f0002, 
	  0xff600005, 0xff620002, 0xff630005, 0xfff90009, 
	};

	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_break_classes) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_start, t_finish;
		t_start = s_break_classes[t_mid] >> 16;
		t_finish = t_start + ((s_break_classes[t_mid] & 0xffff) >> 2);

		if (x < t_start)
			t_high = t_mid;
		else if (x > t_finish)
			t_low = t_mid + 1;
		else
			return s_break_classes[t_mid] & 0x3;
	}

	return 0;
}

enum
{
	kMCUnicodeWordBreakClassNone,
	kMCUnicodeWordBreakClassKatakana,
	kMCUnicodeWordBreakClassALetter,
	kMCUnicodeWordBreakClassMidLetter,
	kMCUnicodeWordBreakClassMidNum,
	kMCUnicodeWordBreakClassMidNumLet,
	kMCUnicodeWordBreakClassNumeric,
	kMCUnicodeWordBreakClassExtendNumLet
};

uint4 MCUnicodeCodepointGetWordBreakClass(uint4 x)
{
	static uint4 s_word_break_classes[] =
	{
		0x00270005, 0x002c0004, 0x002e0004, 0x0030004e, 0x003a0003, 0x003b0004, 0x004100ca, 0x005f0007,
		0x006100ca, 0x00aa0002, 0x00ad0002, 0x00b50002, 0x00b70003, 0x00ba0002, 0x00c000b2, 0x00d800f2,
		0x00f80e4a, 0x02c6005a, 0x02e00022, 0x02ec0002, 0x02ee0002, 0x030003a2, 0x0376000a, 0x037a001a,
		0x037e0004, 0x03860002, 0x03870003, 0x03880012, 0x038c0002, 0x038e009a, 0x03a30292, 0x03f70452,
		0x04830502, 0x0531012a, 0x05590002, 0x05610132, 0x05890004, 0x05910162, 0x05bf0002, 0x05c1000a,
		0x05c4000a, 0x05c70002, 0x05d000d2, 0x05f0001a, 0x05f40003, 0x0600001a, 0x060c000c, 0x06100052,
		0x062101ea, 0x0660004e, 0x066b0006, 0x066c0004, 0x066e032a, 0x06d5009a, 0x06ea002a, 0x06f0004e,
		0x06fa0012, 0x06ff0002, 0x070f01da, 0x074d0322, 0x07c0004e, 0x07ca015a, 0x07f80004, 0x07fa0002,
		0x090101c2, 0x093c008a, 0x09500022, 0x0958005a, 0x0966004e, 0x0971000a, 0x097b0022, 0x09810012,
		0x0985003a, 0x098f000a, 0x099300aa, 0x09aa0032, 0x09b20002, 0x09b6001a, 0x09bc0042, 0x09c7000a,
		0x09cb001a, 0x09d70002, 0x09dc000a, 0x09df0022, 0x09e6004e, 0x09f0000a, 0x0a010012, 0x0a05002a,
		0x0a0f000a, 0x0a1300aa, 0x0a2a0032, 0x0a32000a, 0x0a35000a, 0x0a38000a, 0x0a3c0002, 0x0a3e0022,
		0x0a47000a, 0x0a4b0012, 0x0a510002, 0x0a59001a, 0x0a5e0002, 0x0a66004e, 0x0a70002a, 0x0a810012,
		0x0a850042, 0x0a8f0012, 0x0a9300aa, 0x0aaa0032, 0x0ab2000a, 0x0ab50022, 0x0abc004a, 0x0ac70012,
		0x0acb0012, 0x0ad00002, 0x0ae0001a, 0x0ae6004e, 0x0b010012, 0x0b05003a, 0x0b0f000a, 0x0b1300aa,
		0x0b2a0032, 0x0b32000a, 0x0b350022, 0x0b3c0042, 0x0b47000a, 0x0b4b0012, 0x0b56000a, 0x0b5c000a,
		0x0b5f0022, 0x0b66004e, 0x0b710002, 0x0b82000a, 0x0b85002a, 0x0b8e0012, 0x0b92001a, 0x0b99000a,
		0x0b9c0002, 0x0b9e000a, 0x0ba3000a, 0x0ba80012, 0x0bae005a, 0x0bbe0022, 0x0bc60012, 0x0bca001a,
		0x0bd00002, 0x0bd70002, 0x0be6004e, 0x0c010012, 0x0c05003a, 0x0c0e0012, 0x0c1200b2, 0x0c2a004a,
		0x0c350022, 0x0c3d003a, 0x0c460012, 0x0c4a001a, 0x0c55000a, 0x0c58000a, 0x0c60001a, 0x0c66004e,
		0x0c82000a, 0x0c85003a, 0x0c8e0012, 0x0c9200b2, 0x0caa004a, 0x0cb50022, 0x0cbc0042, 0x0cc60012,
		0x0cca001a, 0x0cd5000a, 0x0cde0002, 0x0ce0001a, 0x0ce6004e, 0x0d02000a, 0x0d05003a, 0x0d0e0012,
		0x0d1200b2, 0x0d2a007a, 0x0d3d003a, 0x0d460012, 0x0d4a001a, 0x0d570002, 0x0d60001a, 0x0d66004e,
		0x0d7a002a, 0x0d82000a, 0x0d85008a, 0x0d9a00ba, 0x0db30042, 0x0dbd0002, 0x0dc00032, 0x0dca0002,
		0x0dcf002a, 0x0dd60002, 0x0dd8003a, 0x0df2000a, 0x0e310002, 0x0e340032, 0x0e47003a, 0x0e50004e,
		0x0eb10002, 0x0eb4002a, 0x0ebb000a, 0x0ec8002a, 0x0ed0004e, 0x0f000002, 0x0f18000a, 0x0f20004e,
		0x0f350002, 0x0f370002, 0x0f390002, 0x0f3e004a, 0x0f49011a, 0x0f71009a, 0x0f86002a, 0x0f90003a,
		0x0f99011a, 0x0fc60002, 0x102b009a, 0x1040004e, 0x1056001a, 0x105e0012, 0x10620012, 0x10670032,
		0x1071001a, 0x1082005a, 0x108f0002, 0x1090004e, 0x10a0012a, 0x10d00152, 0x10fc0002, 0x110002ca,
		0x115f021a, 0x11a8028a, 0x12000242, 0x124a001a, 0x12500032, 0x12580002, 0x125a001a, 0x12600142,
		0x128a001a, 0x12900102, 0x12b2001a, 0x12b80032, 0x12c00002, 0x12c2001a, 0x12c80072, 0x12d801c2,
		0x1312001a, 0x13180212, 0x135f0002, 0x1380007a, 0x13a002a2, 0x1401135a, 0x166f003a, 0x168100ca,
		0x16a00252, 0x16ee0012, 0x17000062, 0x170e0032, 0x172000a2, 0x1740009a, 0x17600062, 0x176e0012,
		0x1772000a, 0x17b400fa, 0x17dd0002, 0x17e0004e, 0x180b0012, 0x1810004e, 0x182002ba, 0x18800152,
		0x190000e2, 0x1920005a, 0x1930005a, 0x1946004e, 0x19b00082, 0x19c8000a, 0x19d0004e, 0x1a0000da,
		0x1b00025a, 0x1b50004e, 0x1b6b0042, 0x1b800152, 0x1bae000a, 0x1bb0004e, 0x1c0001ba, 0x1c40004e,
		0x1c4d0012, 0x1c50004e, 0x1c5a011a, 0x1d000732, 0x1dfe08ba, 0x1f18002a, 0x1f20012a, 0x1f48002a,
		0x1f50003a, 0x1f590002, 0x1f5b0002, 0x1f5d0002, 0x1f5f00f2, 0x1f8001a2, 0x1fb60032, 0x1fbe0002,
		0x1fc20012, 0x1fc60032, 0x1fd0001a, 0x1fd6002a, 0x1fe00062, 0x1ff20012, 0x1ff60032, 0x200b0022,
		0x2018000d, 0x20240005, 0x20270003, 0x202a0022, 0x203f000f, 0x20440004, 0x20540007, 0x20600022,
		0x206a002a, 0x20710002, 0x207f0002, 0x20900022, 0x20d00102, 0x21020002, 0x21070002, 0x210a004a,
		0x21150002, 0x21190022, 0x21240002, 0x21260002, 0x21280002, 0x212a001a, 0x212f0052, 0x213c001a,
		0x21450022, 0x214e0002, 0x21600142, 0x24b6019a, 0x2c000172, 0x2c300172, 0x2c60007a, 0x2c710062,
		0x2c800322, 0x2d00012a, 0x2d3001aa, 0x2d6f0002, 0x2d8000b2, 0x2da00032, 0x2da80032, 0x2db00032,
		0x2db80032, 0x2dc00032, 0x2dc80032, 0x2dd00032, 0x2dd80032, 0x2de000fa, 0x2e2f0002, 0x30050002,
		0x302a002a, 0x30310021, 0x303b000a, 0x3099000a, 0x309b0009, 0x30a002d1, 0x30fc0019, 0x31050142,
		0x313102ea, 0x31a000ba, 0x31f00079, 0x32d00171, 0x330002b9, 0xa0002462, 0xa5000862, 0xa610007a,
		0xa620004e, 0xa62a000a, 0xa64000fa, 0xa6620082, 0xa67c000a, 0xa67f00c2, 0xa7170042, 0xa7220332,
		0xa78b000a, 0xa7fb0162, 0xa840019a, 0xa8800222, 0xa8d0004e, 0xa900004e, 0xa90a011a, 0xa930011a,
		0xaa0001b2, 0xaa40006a, 0xaa50004e, 0xac00fffa, 0xcc005d1a, 0xd800fffa, 0xf80007fa, 0xfb000032,
		0xfb130022, 0xfb1d005a, 0xfb2a0062, 0xfb380022, 0xfb3e0002, 0xfb40000a, 0xfb43000a, 0xfb46035a,
		0xfbd30b52, 0xfd5001fa, 0xfd9201aa, 0xfdf0005a, 0xfe00007a, 0xfe100004, 0xfe130003, 0xfe140004,
		0xfe200032, 0xfe33000f, 0xfe4d0017, 0xfe500004, 0xfe520005, 0xfe540004, 0xfe550003, 0xfe700022,
		0xfe760432, 0xfeff0002, 0xff070005, 0xff0c0004, 0xff0e0005, 0xff1a0003, 0xff1b0004, 0xff2100ca,
		0xff3f0007, 0xff4100ca, 0xff6601b9, 0xff9e0102, 0xffc2002a, 0xffca002a, 0xffd2002a, 0xffda0012,
		0xfff90012
	};

	uint4 t_low, t_high;
	t_low = 0;
	t_high = sizeof(s_word_break_classes) / sizeof(uint4);
	while(t_low < t_high)
	{
		uint4 t_mid;
		t_mid = t_low + (t_high - t_low) / 2;
		
		uint4 t_start, t_finish;
		t_start = s_word_break_classes[t_mid] >> 16;
		t_finish = t_start + ((s_word_break_classes[t_mid] & 0xffff) >> 3);

		if (x < t_start)
			t_high = t_mid;
		else if (x > t_finish)
			t_low = t_mid + 1;
		else
			return s_word_break_classes[t_mid] & 0x7;
	}

	return 0;
}

// MW-2008-11-03: [[ Bug ]] The rule ExtendNumLet * ExtendNumLet was missing thus stopping
//   a__b being selected as a single word.
bool MCUnicodeCanBreakWordBetween(uint4 xc, uint4 x, uint4 y, uint4 yc)
{
	// Our simplified rules are:
	//   WB5:                          ALetter * ALetter
	//   WB6:                          ALetter * (MidLetter | MidNumLet) ALetter
	//   WB7:  ALetter (MidLetter | MidNumLet) * ALetter
	//   WB8:                          Numeric * Numeric
	//   WB9:                          ALetter * Numeric
	//   WB10:                         Numeric * ALetter
	//   WB11:    Numeric (MidNum | MidNumLet) * Numeric
	//   WB12:                         Numeric * (MidNum | MidNumLet) Numeric
	//   WB13:                        Katakana * Katakana
	//   WB13a: (ALetter | Numeric | Katakana | ExtendNumLet) * ExtendNumLet
	//   WB13b:                   ExtendNumLet * (ALetter | Numeric | Katakana)

	// We perform these rule checks as follows:
	// if (x is ALetter)
	//   WB5
	//   WB9
	//   WB13a-ALetter
	//   WB6
	// if (x is Numeric)
	//   WB8
	//   WB10
	//   W13a-Numeric
	//   WB12
	// if (x is Katakana)
	//   WB13
	//   WB13a-Katakana
	// if (y is ALetter)
	//   WB13b-ALetter
	//   WB7
	// if (y is Numeric)
	//   WB13b-Numeric
	//   WB11
	// if (y is Katakana)
	//   WB13b-Katakana
	// if (y is ExtendNumLet)
	//   WB13-ExtendNumLet

	uint4 x_class;
	x_class = MCUnicodeCodepointGetWordBreakClass(x);

	uint4 y_class;
	y_class = MCUnicodeCodepointGetWordBreakClass(y);

	switch(x_class)
	{
	case kMCUnicodeWordBreakClassALetter:
		// WB5
		if (y_class == kMCUnicodeWordBreakClassALetter)
			return false;

		// WB9
		if (y_class == kMCUnicodeWordBreakClassNumeric)
			return false;

		// WB13a
		if (y_class == kMCUnicodeWordBreakClassExtendNumLet)
			return false;

		// WB6
		if (y_class == kMCUnicodeWordBreakClassMidLetter || y_class == kMCUnicodeWordBreakClassMidNumLet)
		{
			uint4 yc_class;
			yc_class = MCUnicodeCodepointGetWordBreakClass(yc);
			if (yc_class == kMCUnicodeWordBreakClassALetter)
				return false;
		}
	break;
	
	case kMCUnicodeWordBreakClassNumeric:
		// WB8
		if (y_class == kMCUnicodeWordBreakClassNumeric)
			return false;

		// WB10
		if (y_class == kMCUnicodeWordBreakClassALetter)
			return false;

		// WB13a
		if (y_class == kMCUnicodeWordBreakClassExtendNumLet)
			return false;

		// WB12
		if (y_class == kMCUnicodeWordBreakClassMidNum || y_class == kMCUnicodeWordBreakClassMidNumLet)
		{
			uint4 yc_class;
			yc_class = MCUnicodeCodepointGetWordBreakClass(yc);
			if (yc_class == kMCUnicodeWordBreakClassNumeric)
				return false;
		}
	break;
	
	case kMCUnicodeWordBreakClassKatakana:
		// WB13
		if (y_class == kMCUnicodeWordBreakClassKatakana)
			return false;
		
		// WB13a
		if (y_class == kMCUnicodeWordBreakClassExtendNumLet)
			return false;
	break;
	}

	switch(y_class)
	{
	case kMCUnicodeWordBreakClassALetter:
		// WB13b
		if (x_class == kMCUnicodeWordBreakClassExtendNumLet)
			return false;

		// WB7
		if (x_class == kMCUnicodeWordBreakClassMidLetter || x_class == kMCUnicodeWordBreakClassMidNumLet)
		{
			uint4 xc_class;
			xc_class = MCUnicodeCodepointGetWordBreakClass(xc);
			if (xc_class == kMCUnicodeWordBreakClassALetter)
				return false;
		}
	break;
	
	case kMCUnicodeWordBreakClassNumeric:
		// WB13b
		if (x_class == kMCUnicodeWordBreakClassExtendNumLet)
			return false;

		// WB11
		if (x_class == kMCUnicodeWordBreakClassMidNum || x_class == kMCUnicodeWordBreakClassMidNumLet)
		{
			uint4 xc_class;
			xc_class = MCUnicodeCodepointGetWordBreakClass(xc);
			if (xc_class == kMCUnicodeWordBreakClassNumeric)
				return false;
		}
	break;
	
	case kMCUnicodeWordBreakClassKatakana:
	case kMCUnicodeWordBreakClassExtendNumLet:
			// WB13b
		if (x_class == kMCUnicodeWordBreakClassExtendNumLet)
			return false;
	break;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////
