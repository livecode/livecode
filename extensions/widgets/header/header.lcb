/*
Copyright (C) 2015 Runtime Revolution Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

/*

This widget is a header bar.

Name: headerTitle
Type: property
Summary: Sets the title of the header bar

Syntax:
set the headerTitle of <widget> to <pTitle>
get the headerTitle of <widget>

Parameters:
pTitle (string): The text of the title of the header bar.

Description:
Sets the title of the header bar to any string.

Name: headerSubtitle
Type: property
Summary: Sets the subtitle of the header bar

Syntax:
set the headerSubtitle of <widget> to <pSubtitle>
get the headerSubtitle of <widget>

Parameters:
pSubtitle (string): The text of the subtitle of the header bar.

Description:
Sets the subtitle of the header bar to any string.

Name: headerSubtitleIsOn
Type: property
Summary: Sets whether there is a subtitle in the header bar

Syntax:
set the headerSubtitleIsOn of <widget> to <pSubtitleIsOn>
get the headerSubtitleIsOn of <widget>

Parameters:
pSubtitleIsOn (boolean): True or false

Description:
Controls whether there is a subtitle or not.

Name: headerActions
Type: property
Summary: Sets the actions of the header bar

Syntax:
set the headerActions of <widget> to <pActions>
get the headerActions of <widget>

Parameters:
pActions (list): The list of actions.

Description:
Sets the actions of the header bar from pActions, where pActions is a line delimited list of the actions, where each line is a comma delimited list
of the different components of the action: name, label, icon

Name: actionStyle
Type: property
Summary: Sets the header actions display style.

Syntax:
set the actionStyle of <widget> to <pActionStyle>
get the actionStyle of <widget>

Parameters:
pActionStyle (enum): The style of the header actions display.
-"icons": Show the icons
-"names": Show the names

Description:
Sets the header actions display style of the control.

Name: enableBackButton
Type: property
Summary: Controls whether the back button is enabled or not.

Syntax:
set the enableBackButton of <widget> to <pEnable>
get the enableBackButton of <widget>

Parameters:
pEnable (boolean): True or false

Description:
Controls whether the back button is enabled or not.

Name: showBackIcon
Type: property
Summary: Controls whether the back icon is displayed.

Syntax:
set the showBackIcon of <widget> to <pShow>
get the showBackIcon of <widget>

Parameters:
pShow (boolean): True or false

Description:
Sets whether the back icon is showing or not.

Name: backButtonLabel
Type: property
Summary: Sets the label of the back button.

Syntax:
set the backButtonLabel of <widget> to <pLabel>
get the backButtonLabel of <widget>

Parameters:
pLabel (string): the label of the back button

Description:
Sets the label of the back button.

Name: actionColor
Type: property
Summary: Sets the color of the actions and the back button.

Syntax:
set the actionColor of <widget> to <pColor>
get the actionColor of <widget>

Parameters:
pColor (color): The color of the actions and back button

Description:
Sets the color of the actions and the back button.

Name: selectedActionColor
Type: property
Summary: Sets the color of the actions and the back button when they are selected.

Syntax:
set the selectedActionColor of <widget> to <pSelectedColor>
get the selectedActionColor of <widget>

Parameters:
pSelectedColor (color): The selected color of the actions and back button

Description:
Sets the color of the actions and the back button when they are selected.

Name: showSearchIcon
Type: property
Summary: Sets whether there is a search icon in the header bar.

Syntax:
set the showSearchIcon of <widget> to <pShow>
get the showSearchIcon of <widget>

Parameters:
pShow (boolean): True or false

Description:
Controls whether the search icon is displayed in the header bar.
*/

-- declaring the extension as a widget, followed by identifier
widget com.livecode.extensions.livecode.header

-- dependency declarations
use com.livecode.canvas
use com.livecode.widget
use com.livecode.engine
use com.livecode.library.iconSVG

-- metadata
metadata title is "Header"
metadata author is "LiveCode"
metadata version is "1.0.0"

-- property declarations
property headerTitle          get mHeaderTitle           set setHeaderTitle
property headerSubtitle       get mHeaderSubtitle        set setHeaderSubtitle
property headerSubtitleIsOn   get mHeaderSubtitleIsOn    set setHeaderSubtitleIsOn
property headerActions        get getHeaderActions       set setHeaderActions
property actionNames          get getActionNames         set setActionNames
property actionLabels         get getActionLabels        set setActionLabels
property actionIcons          get getActionIcons         set setActionIcons
property actionStyle          get mActionStyle           set setActionStyle
property showBackIcon         get mShowBackIcon          set setShowBackIcon
property showBackLabel        get mShowBackLabel         set setShowBackLabel
property backButtonLabel      get mBackButtonLabel       set setBackButtonLabel
property actionColor          get getActionColor         set setActionColor
property selectedActionColor  get getSelectedActionColor set setSelectedActionColor
property showSearchIcon       get mShowSearchIcon        set setShowSearchIcon

-- property metadata
metadata headerTitle.default is "Title"
metadata headerTitle.label is "Title"

metadata headerSubtitle.default is "Subtitle"
metadata headerSubtitle.label is "Subtitle"

metadata headerSubtitleIsOn.editor is "com.livecode.pi.boolean"
metadata headerSubtitleIsOn.default is "false"
metadata headerSubtitleIsOn.label is "Show Subtitle"

metadata headerActions.editor is "com.livecode.pi.navbar"
metadata headerActions.label is "Header Actions"

metadata actionNames.user_visible is "false"
metadata actionLabels.user_visible is "false"
metadata actionIcons.user_visible is "false"

metadata actionStyle.editor is "com.livecode.pi.enum"
metadata actionStyle.options is "icons,names"
metadata actionStyle.default is "icons"
metadata actionStyle.label is "Action Display Style"

metadata showBackIcon.editor is "com.livecode.pi.boolean"
metadata showBackIcon.default is "true"
metadata showBackIcon.label is "Show Back Icon"

metadata showBackLabel.editor is "com.livecode.pi.boolean"
metadata showBackLabel.default is "true"
metadata showBackLabel.label is "Show Back Label"

metadata backButtonLabel.default is "Back"
metadata backButtonLabel.label is "Back Label"

metadata actionColor.editor is "com.livecode.pi.color"
metadata actionColor.default is "0,121,255"
metadata actionColor.label is "Action Color"

metadata selectedActionColor.editor is "com.livecode.pi.color"
metadata selectedActionColor.default is "51,153,255"
metadata selectedActionColor.label is "Selected Action Color"

metadata showSearchIcon.editor is "com.livecode.pi.boolean"
metadata showSearchIcon.default is "false"
metadata showSearchIcon.label is "Show Search Icon"

-- private instance variables
private variable mHeaderTitle as String
private variable mHeaderSubtitle as String
private variable mHeaderSubtitleIsOn as Boolean
private variable mHeaderActions as List
private variable mActionStyle as String
private variable mShowBackIcon as Boolean
private variable mShowBackLabel as Boolean
private variable mBackButtonLabel as String
private variable mActionColor as Color
private variable mSelectedActionColor as Color
private variable mShowSearchIcon as Boolean

private variable mIconColor as Color
private variable mTitleRatio as Real
private variable mIconTop as Real
private variable mIconBottom as Real
private variable mIconWidth as Real
private variable mLabelTop as Real
private variable mLabelBottom as Real
private variable mSubtitleCenter as Real
private variable mSelectedAction as Integer
private variable mRight as Real
private variable mLetterCount as Integer
private variable mActionRects as List

-- constants (some defined as varibales)
private variable kBackgroundColor as List
private variable kBlackColor as List

constant kMargin is 8
constant kActionRatio is 0.265625
constant kSubtitleRatio is 0.171875

public handler OnSave(out rProperties as Array)
   put the empty array into rProperties

   put mHeaderTitle into rProperties["headerTitle"]
   put mHeaderSubtitle into rProperties["headerSubtitle"]
   put mHeaderSubtitleIsOn into rProperties["headerSubtitleIsOn"]
   put getHeaderActions() into rProperties["headerActions"]
   put mActionStyle into rProperties["actionStyle"]
   put mShowBackIcon into rProperties["showBackIcon"]
   put mShowBackLabel into rProperties["showBackLabel"]
   put mBackButtonLabel into rProperties["backButtonLabel"]
   put mActionColor into rProperties["actionColor"]
   put mSelectedActionColor into rProperties["selectedActionColor"]
   put mShowSearchIcon into rProperties["showSearchIcon"]

   return rProperties
end handler

public handler OnLoad(in pProperties as Array)
   put pProperties["headerTitle"] into mHeaderTitle
   put pProperties["headerSubtitle"] into mHeaderSubtitle
   put pProperties["headerSubtitleIsOn"] into mHeaderSubtitleIsOn
   setHeaderActions(pProperties["headerActions"])
   put pProperties["actionStyle"] into mActionStyle
   put pProperties["showBackIcon"] into mShowBackIcon
   put pProperties["showBackLabel"] into mShowBackLabel
   put pProperties["backButtonLabel"] into mBackButtonLabel
   put pProperties["actionColor"] into mActionColor
   put pProperties["selectedActionColor"] into mSelectedActionColor
   put pProperties["showSearchIcon"] into mShowSearchIcon
end handler

public handler OnCreate()

   -- creating a list of actions
   variable tHeaderActions as List
   put the empty list into tHeaderActions

   variable tArray as Array
   put the empty array into tArray

   put "edit" into tArray["name"]
   put "Edit" into tArray["label"]
   put "edit" into tArray["icon_name"]
   put "" into tArray["selected_icon_name"]
   put "" into tArray["icon"]
   push tArray onto tHeaderActions

   put "add" into tArray["name"]
   put "Add" into tArray["label"]
   put "plus" into tArray["icon_name"]
   put "" into tArray["selected_icon_name"]
   put "" into tArray["icon"]
   push tArray onto tHeaderActions

   put tHeaderActions into mHeaderActions

   -- properties
   put "Yesterday" into mHeaderTitle
   put "18:50" into mHeaderSubtitle
   put true into mHeaderSubtitleIsOn
   put "icons" into mActionStyle
   put true into mShowBackIcon
   put true into mShowBackLabel
   put "Back" into mBackButtonLabel
   put color [0, 121/255, 1] into mActionColor
   put color [0, 1, 0] into mSelectedActionColor
   put true into mShowSearchIcon

   -- variables
   put 0 into mSelectedAction
   put 0 into mRight
   put 0 into mLetterCount

   -- constants (defined as variables)
   put [247/255,247/255,247/255] into kBackgroundColor
   put [0,0,0] into kBlackColor

end handler

public handler OnPaint()

   updateVariables()

   -- draw the background rectangle
   set the paint of this canvas to fetchPaint("background")
   fill fetchPath("background") on this canvas

   -- draw the bottom line
   set the paint of this canvas to fetchPaint("line")
   fill fetchPath("line") on this canvas

   -- filling in the text of the title
   set the font of this canvas to fetchFont("title")
   set the paint of this canvas to fetchPaint("title")
   fill text mHeaderTitle at center of fetchRect("title") on this canvas

   -- fill in the text of the subtitle
   if mHeaderSubtitleIsOn is true then
      set the font of this canvas to fetchFont("subtitle")
      set the paint of this canvas to fetchPaint("title")
      fill text mHeaderSubtitle at center of fetchRect("subtitle") on this canvas
   end if

   -- drawing the back button
   set the paint of this canvas to fetchPaint("backButton")

   if mShowBackIcon is true then
      fill fetchPath("backIcon") on this canvas
   end if

   if mShowBackLabel is true then
      set the font of this canvas to fetchFont("label")
      fill text mBackButtonLabel at left of fetchRect("backLabel") on this canvas
   end if

   -- draw the actions
   if mHeaderActions is not the empty list then

      variable tX as Integer
      variable tActionsCount as Integer

      put the number of elements in mHeaderActions into tActionsCount

      repeat with tX from 1 up to tActionsCount

         if tX+2 is mSelectedAction then
            set the paint of this canvas to solid paint with mSelectedActionColor
         else
            set the paint of this canvas to solid paint with mActionColor
         end if

         if mActionStyle is "icons" then
            drawActionIcon(mHeaderActions[tX]["icon_name"])
         else if mActionStyle is "names" then
            drawActionName(mHeaderActions[tX]["label"])
         end if

      end repeat
   end if

   -- draw the search icon
   if mShowSearchIcon is true then
      set the paint of this canvas to fetchPaint("searchIcon")
      fill fetchPath("searchIcon") on this canvas
   end if

end handler

public handler OnMouseDown()
   -- the icons change color when they are pressed down
   variable tSelectedDown as Integer
   put fetchSelectedItem() into tSelectedDown

   if tSelectedDown > 0 then
      put tSelectedDown into mSelectedAction
      redraw all
   end if

end handler

public handler OnMouseUp()

   -- the icons change back to their original colors on mouse up
   put 0 into mSelectedAction
   redraw all

   -- the relevant commands are dispatched to the script object
   variable tSelectedUp as Integer
   put fetchSelectedItem() into tSelectedUp

   if tSelectedUp > 2 then

      variable tActionCount as Integer
      variable tNumActions as Integer

      put the number of elements in element 1 of mHeaderActions into tNumActions

      repeat with tActionCount from 1 up to tNumActions

         if tActionCount is tSelectedUp-2 then
            post "headerAction" with [mHeaderActions[tActionCount]["name"]]
         end if

      end repeat

   else if tSelectedUp = 1 then
      post "backAction"

   else if tSelectedUp = 2 then
      post "search"
   end if

end handler

private handler updateVariables() returns nothing

   if mHeaderSubtitleIsOn is false then
      put 17/64 into mTitleRatio
   else
      put 15/64 into mTitleRatio
   end if

   variable tH
   put my height into tH

   put tH*(30.5/64) into mIconTop
   put tH*(51.5/64) into mIconBottom
   put tH*(13/64) into mIconWidth
   put tH*(9/64) into mLabelTop
   put tH*(73/64) into mLabelBottom
   put tH*(43/64) into mSubtitleCenter

   put (my width - kMargin) into mRight
   put 0 into mLetterCount

   put the empty list into mActionRects
end handler

private handler drawActionIcon(in pIconName as String) returns nothing

   variable tIconPath as Path
   variable tIconRect as Rectangle

   put path iconSVGPathFromName(pIconName) into tIconPath
   put fetchRect("actionIcon") into tIconRect

   setIconPath(tIconRect, tIconPath)
   fill tIconPath on this canvas

   push tIconRect onto back of mActionRects

end handler

private handler drawActionName(in pActionLabel as String) returns nothing
   put the number of chars in pActionLabel into mLetterCount

   variable tActionRect as Rectangle
   put fetchRect("actionLabel") into tActionRect

   set the font of this canvas to fetchFont("label")
   fill text pActionLabel at right of tActionRect on this canvas

   push tActionRect onto back of mActionRects

end handler

private handler setIconPath(in pTargetRect as Rectangle, inout xPath as Path)

	-- Scale the icon
	variable tBounds
	put the bounding box of xPath into tBounds

	-- Scale appropriately
	variable tXScale as Real
	variable tYScale as Real

	put the width of pTargetRect / the width of tBounds into tXScale
	put the height of pTargetRect / the height of tBounds into tYScale

	if tXScale > tYScale then
		put tYScale into tXScale
	else
		put tXScale into tYScale
	end if

   scale xPath by [tXScale, tYScale]

	variable tXTranslate as Real
	variable tYTranslate as Real

   put the bounding box of xPath into tBounds

	put the left of pTargetRect - the left of tBounds into tXTranslate
	put the top of pTargetRect - the top of tBounds into tYTranslate

    variable tXDiff as Real
    variable tYDiff as Real

    put the width of pTargetRect - the width of tBounds into tXDiff
    put the height of pTargetRect - the height of tBounds into tYDiff

	-- align center
	divide tXDiff by 2
	divide tYDiff by 2

	translate xPath by [tXTranslate + tXDiff, tYTranslate + tYDiff]
end handler

private handler fetchPath(in pObject as String) returns Path
   variable tIconPath as Path
   variable tIconRect as Rectangle

   variable tH as Real
   variable tW as Real
   put my width into tW
   put my height into tH

   if pObject is "background" then
      return rectangle path of rectangle [0, 0, tW, tH-1]

   else if pObject is "line" then
      return rectangle path of rectangle [0, tH-1, tW, tH]

   else if pObject is "backIcon" then
      put path iconSVGPathFromName("angle left") into tIconPath
      put rectangle [kMargin, mLabelTop, kMargin + mIconWidth, mLabelBottom] into tIconRect

      setIconPath(tIconRect, tIconPath)
      return tIconPath

   else if pObject is "searchIcon" then
      variable tLeft as Real
      variable tRight as Real

      if mHeaderActions is empty then
         put tW - kMargin into tRight
      else
         if mActionStyle is "icons" then
            put mRight into tRight
         else
            put mRight - kMargin into tRight
         end if
      end if
      put tRight - mIconWidth into tLeft

      put path iconSVGPathFromName("search") into tIconPath
      put rectangle [tLeft, mLabelTop, tRight, mLabelBottom] into tIconRect

      setIconPath(tIconRect, tIconPath)
      return tIconPath

   end if
end handler

private handler fetchRect(in pObject as String) returns Rectangle

   variable tRect as Rectangle
   variable tLeft as Real
   variable tTop as Real
   variable tRight as Real
   variable tBottom as Real
   variable tH as Real
   variable tSize as Real

   put my height into tH
   put tH*kActionRatio/2 into tSize

   if pObject is "title" then
      if mHeaderSubtitleIsOn is false then
         return rectangle [0, mLabelTop, my width, mLabelBottom]
      else
         put mSubtitleCenter-tH*mTitleRatio-kMargin/2 into tTop
         put mSubtitleCenter-kMargin/2 into tBottom
         return rectangle [0, tTop, my width, tBottom]
      end if

   else if pObject is "subtitle" then
      put kMargin/2 + mSubtitleCenter into tTop
      put kMargin/2 + mSubtitleCenter + tH*kSubtitleRatio into tBottom
      return rectangle [0, tTop, my width, tBottom]

   else if pObject is "backLabel" then
      if mShowBackIcon is true then
         put 3*kMargin/2 + mIconWidth into tLeft
      else
         put kMargin into tLeft
      end if
      return rectangle [tLeft, mLabelTop, my width, mLabelBottom]

   else if pObject is "actionIcon" then
      put rectangle [mRight - mIconWidth, mLabelTop, mRight, mLabelBottom] into tRect
      put (mRight - mIconWidth - 2*kMargin) into mRight
      return tRect

   else if pObject is "actionLabel" then

      put rectangle [mRight - mLetterCount*tSize, mLabelTop, mRight, mLabelBottom] into tRect
      put (mRight - mLetterCount*tSize - kMargin) into mRight
      return tRect

   end if
end handler

private handler fetchPaint(in pObject as String) returns Paint
   variable tPaint as Paint

   if pObject is "background" then
      put solid paint with color kBackgroundColor into tPaint

   else if pObject is "line" then
      put solid paint with color [0, 0, 0, 0.2] into tPaint

   else if pObject is "title" then
      put solid paint with color kBlackColor into tPaint

   else if pObject is "backButton" then
      if mSelectedAction is 1 then
         put solid paint with mSelectedActionColor into tPaint
      else
         put solid paint with mActionColor into tPaint
      end if

   else if pObject is "searchIcon" then
      if mSelectedAction is 2 then
         put solid paint with mSelectedActionColor into tPaint
      else
         put solid paint with mActionColor into tPaint
      end if

   end if

   return tPaint
end handler

private handler fetchFont(in pType as String) returns Font

   variable tSize as Number
   variable tFont as String

   if pType is "title" then
      put (my height)*mTitleRatio into tSize
      put "Helvetica Neue Regular" into tFont

   else if pType is "subtitle" then
      put (my height)*kSubtitleRatio into tSize
      put "Helvetice Neue Regular" into tFont

   else if pType is "label" then
      put (my height)*kActionRatio into tSize
      put "Helvetica Neue Regular" into tFont

   end if

   return font tFont at size tSize
end handler

private handler fetchSelectedItem() returns Integer

   variable tSelected as Integer
   variable tBackRect as Rectangle
   variable tSearchRect as Rectangle

   put fetchBackRect() into tBackRect
   put fetchSearchRect() into tSearchRect

   variable tClick as Point
   put the click position into tClick

   if tClick is within tBackRect then
      put 1 into tSelected
   else if tClick is within tSearchRect then
      put 2 into tSelected
   else
      put locToAction(tClick) into tSelected
   end if

   return tSelected

end handler

private handler fetchBackRect() returns Rectangle
   variable tBackRect as Rectangle

   if mShowBackLabel is true then

      variable tLetterCount as Integer
      variable tSize as Real
      variable tWidth as Real

      put the number of chars in mBackButtonLabel into tLetterCount
      put (my height)*kActionRatio/2 into tSize
      put tLetterCount*tSize into tWidth

   end if

   if mShowBackIcon is true and mShowBackLabel is false then
      put rectangle [kMargin, mLabelTop, kMargin + mIconWidth, mLabelBottom] into tBackRect
   else if mShowBackIcon is false and mShowBackLabel is true then
      put rectangle [kMargin, mLabelTop, kMargin + tWidth, mLabelBottom] into tBackRect
   else if mShowBackIcon is true and mShowBackLabel is true then
      put rectangle [kMargin, mLabelTop, kMargin + mIconWidth + tWidth, mLabelBottom] into tBackRect
   else
      put rectangle [0,0,0,0] into tBackRect
   end if

   return tBackRect
end handler

private handler fetchSearchRect() returns Rectangle
   variable tSearchRect as Rectangle

   if mShowSearchIcon is true then
      put rectangle [mRight - mIconWidth - kMargin, mLabelTop, mRight - kMargin, mLabelBottom] into tSearchRect
   else
      put rectangle [0,0,0,0] into tSearchRect
   end if

   return tSearchRect
end handler

private handler locToAction(in pLoc as Point) returns Integer
   variable tX as Integer

   repeat with tX from 1 up to the number of elements in mActionRects
      if pLoc is within (element tX of mActionRects) then
         return (tX + 2)
      end if
   end repeat

   return 0
end handler

-- this handler converts an RGBA color to a string
private handler colorToString(in pColor as Color) returns String

   variable tRed as Integer
   variable tGreen as Integer
   variable tBlue as Integer
   variable tAlpha as Integer

   put the rounded of ((the red of pColor)*255) into tRed
   put the rounded of ((the green of pColor)*255) into tGreen
   put the rounded of ((the blue of pColor)*255) into tBlue
   put the rounded of ((the alpha of pColor)*255) into tAlpha

   return stripZeros(tRed formatted as string) & "," & stripZeros(tGreen formatted as string) & \
      "," & stripZeros(tBlue formatted as string) & "," & stripZeros(tAlpha formatted as string)

end handler
--

-- this handler converts a string to an RGBA color
private handler stringToColor(in pString as String) returns Color

   variable tStringList as List
   variable tColorList as List
   variable tComponent

   split pString by "," into tStringList
   put the empty list into tColorList

   variable tComponentCount
	put the number of elements in tStringList into tComponentCount
	if tComponentCount is not 3 and tComponentCount is not 4 then
		-- Invalid number of components detected
		throw "Invalid color"
	end if

   repeat for each element tComponent in tStringList
      push (tComponent parsed as number)/255 onto back of tColorList
   end repeat

   return color tColorList

end handler
--

-- this handler strips the zeros when an integer is formatted as a string
private handler stripZeros(in pString as String) returns String
   if pString contains "." then
      repeat while ((the last char of pString) is in ".0")
         if the last char of pString is "." then
            delete the last char of pString
            exit repeat
         else
            delete the last char of pString
         end if
      end repeat
   end if
   return pString
end handler
--

-- this handler returns an array of the default action
private handler defaultActionsArray() returns Array
   variable tArray as Array
   put the empty array into tArray
   put "action" into tArray["name"]
   put "Action" into tArray["label"]
   put "circle"into tArray["icon_name"]
   put "" into tArray["selected_icon_name"]
   put "" into tArray["icon"]
   return tArray
end handler
--

--------------------------------------------------------------------------------
--
-- Get Handlers
--
--------------------------------------------------------------------------------

-- this handler converts mHeaderActions into a form for output in the PI
private handler getHeaderActions() returns Array
   return listToArray(mHeaderActions)
end handler

private handler getActionNames() returns String
   return getDataElement("name", mHeaderActions)
end handler

private handler getActionLabels() returns String
   return getDataElement("label", mHeaderActions)
end handler

private handler getActionIcons() returns String
   return getDataElement("icon_name", mHeaderActions)
end handler

private handler getActionSelectedIcons() returns String
   return getDataElement("selected_icon_name", mHeaderActions)
end handler

-- these handlers convert the color properties for output in the PI
private handler getActionColor() returns String
   return colorToString(mActionColor)
end handler

private handler getSelectedActionColor() returns String
   return colorToString(mSelectedActionColor)
end handler

--------------------------------------------------------------------------------
--
-- Set Handlers
--
--------------------------------------------------------------------------------

private handler setHeaderTitle(in pTitle as String) returns nothing
   put pTitle into mHeaderTitle
   redraw all
end handler

private handler setHeaderSubtitle(in pSubtitle as String) returns nothing
   put pSubtitle into mHeaderSubtitle
   redraw all
end handler

private handler setHeaderSubtitleIsOn(in pSubtitleIsOn as Boolean) returns nothing
   put pSubtitleIsOn into mHeaderSubtitleIsOn
   redraw all
end handler

-- this handler sets the actions, converting from a string to the correct format
private handler setHeaderActions(in pActions as Array) returns nothing
   setData(pActions, the keys of defaultActionsArray(), mHeaderActions)
   redraw all
end handler

private handler setActionNames(in pNames as String) returns nothing
   setPrimaryDataElement("name", pNames, defaultActionsArray(), mHeaderActions)
   redraw all
end handler

private handler setActionLabels(in pLabels as String) returns nothing
   setDataElement("label", pLabels, defaultActionsArray(), mHeaderActions)
   redraw all
end handler

private handler setActionIcons(in pIcons as String) returns nothing
   setDataElement("icon_name", pIcons, defaultActionsArray(), mHeaderActions)
   redraw all
end handler

private handler setActionSelectedIcons(in pSelectedIcons as String) returns nothing
   setDataElement("selected_icon_name", pSelectedIcons, defaultActionsArray(), mHeaderActions)
   redraw all
end handler

private handler setActionStyle(in pActionStyle as String) returns nothing
   put pActionStyle into mActionStyle
   redraw all
end handler

private handler setShowBackIcon(in pShow as Boolean) returns nothing
   put pShow into mShowBackIcon
   redraw all
end handler

private handler setShowBackLabel(in pShow as Boolean) returns nothing
   put pShow into mShowBackLabel
   redraw all
end handler

private handler setBackButtonLabel(in pLabel as String) returns nothing
   put pLabel into mBackButtonLabel
   redraw all
end handler

private handler setActionColor(in pColor as String) returns nothing
   put stringToColor(pColor) into mActionColor
   redraw all
end handler

private handler setSelectedActionColor(in pColor as String) returns nothing
   put stringToColor(pColor) into mSelectedActionColor
   redraw all
end handler

private handler setShowSearchIcon(in pShow as Boolean) returns nothing
   put pShow into mShowSearchIcon
   redraw all
end handler

--------------------------------------------------------------------------------
--
-- Data utilities
--
--------------------------------------------------------------------------------

private handler listToArray(in pList as List) returns Array
	variable tCount
	variable tArray
	put the empty array into tArray

	variable tKey as String
	repeat with tCount from 1 up to the number of elements in pList
		put tCount formatted as string into tKey
		put defaultActionsArray() into tArray[tKey]

		variable tAttribute as String
		repeat for each key tAttribute in tArray[tKey]
			put pList[tCount][tAttribute] into tArray[tKey][tAttribute]
		end repeat
	end repeat
	return tArray
end handler

private handler setData(in pArray as Array, in pKeys as List, out rList as List)
	-- Excessive hoop-jumping to work around the fact that keys of numerically keyed LCS array
	-- comes into LCB as strings, and therefore must be parsed as number to sort, then formatted back
	-- to be used as keys again. Because parse/format of integer doesn't currently roundtrip, we need to
	-- create a lookup from the original strings.
	variable tKey
	variable tOrder as List
	put the empty list into tOrder
	variable tLookup as Array
	put the empty array into tLookup
	variable tNumericKey as Number
	repeat for each key tKey in pArray
		put tKey parsed as number into tNumericKey
		push tNumericKey onto tOrder
		put tKey into tLookup[tNumericKey formatted as string]
	end repeat
	sort tOrder in ascending numeric order

	variable tOrderKey
	variable tElement as Array
	variable tList as List
	put the empty list into tList

	variable tOriginalKey as String
	repeat for each element tOrderKey in tOrder
		put the empty array into tElement
		repeat for each element tKey in pKeys
			put tLookup[tOrderKey formatted as string] into tOriginalKey
			put pArray[tOriginalKey][tKey] into tElement[tKey]
		end repeat
		if tElement["label"] is "" then
			put "New Item" into tElement["label"]
		end if

		push tElement onto tList
	end repeat

	put tList into rList

	redraw all
end handler

private handler getDataElement(in pElementName as String, in pList as List) returns String
	variable tList
	put the empty list into tList

	variable tElement
	repeat for each element tElement in pList
		push tElement[pElementName] onto tList
	end repeat

	variable tElements
	combine tList with "," into tElements
	return tElements
end handler

private handler setDataElement(in pElementName as String, in pElements as String, in pDefaultArray as Array, inout xList as List)
	variable tElements
	split pElements by "," into tElements

	variable tCount
	put 0 into tCount

	variable tElement
	repeat for each element tElement in xList
		add 1 to tCount
		if tCount > the number of elements in tElements then
			put pDefaultArray[pElementName] into xList[tCount][pElementName]
		else
			put tElements[tCount] into xList[tCount][pElementName]
		end if
	end repeat

	-- If we there are more of the given element than there are items, generate more
	add 1 to tCount
	repeat with tCount from tCount up to the number of elements in tElements
		push pDefaultArray onto xList
		put tElements[tCount] into xList[tCount][pElementName]
	end repeat

	redraw all
end handler

-- Only the primary data element ("name") can *reduce* the number of elements in the data list.
private handler setPrimaryDataElement(in pElementName as String, in pElements as String, in pDefaultArray as Array, inout xList as List)
	variable tElements
	split pElements by "," into tElements

	variable tCount
	put 0 into tCount

	variable tElement
	repeat for each element tElement in tElements
		add 1 to tCount
		if tCount > the number of elements in xList then
			push pDefaultArray onto xList
		end if

		put tElement into xList[tCount][pElementName]
	end repeat

	-- If we there are more items than there are primary elements, pop them off.
	add 1 to tCount
	repeat with tCount from tCount up to the number of elements in xList
		pop xList
	end repeat

	redraw all
end handler

end widget
