/*
Copyright (C) 2015-2016 LiveCode Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

/**
The navigation bar widget is intended for use in mobile apps for
switching between cards, although there are many other possible uses.

The widget displays a row of navigation items.  Each of these has a
<itemNames|name>, which identifies it.  Depending on the selected
<itemStyle>, the items may display a <itemLabels|label>,
<itemIcons|icon>, or both.  All of the navigation item data is
available as a single array via the <itemArray> property.

At any time, one of the navigation items may be
<hilitedItemName|highlighted>.  This is useful, for example, for
indicating the current card.  When the user clicks one of the
navigation items, the widget sends a <hiliteChanged> message.

References: hiliteChanged(message), hilitedItemName(property),
itemArray(property), itemIcons(property), itemLabels(property),
itemNames(property), itemStyle(property)

Name: hiliteChanged
Type: message
Syntax: on hiliteChanged
Summary: Sent when a navigation item is selected

Example:
on hiliteChanged
	go card the hilitedItemName of me
end hiliteChanged

Description:
The <hiliteChanged> message is sent when the highlighted navigation
item changes, either by clicking on the navigation bar or by setting
the <hilitedItem> or <hilitedItemName> properties.

References: hilitedItem (property), hilitedItemName (property)

Name: hiliteColor
Type: Property
Syntax: set the hiliteColor of <widget> to <color>
Syntax: get the hiliteColor of <widget>

Summary: The color of the highlighted navigation item

Description:
The <hiliteColor> is used to draw the icon and/or label of the
navigation item that is <hilitedItemName|currently highlighted>.

Related: hilitedItemName(property)

Name: foreColor
Type: property
Syntax: set the foreColor of <widget> to <color>
Syntax: get the foreColor of <widget>

Summary: The color of the navigation items that are not highlighted

Description:
The <foreColor> is used to draw the icons and/or labels of the
navigation items that are not <hilitedItemName|currently highlighted>.

Related: hilitedItemName(property)

Name: backColor
Type: property
Syntax: set the backColor of <widget> to <color>
Syntax: get the backColor of <widget>

Summary: The color of the navigation bar background

Description:
When the navigation bar has an <opaque> background, it is filled with
the <backColor>.

Related: opaque(property)

Name: borderColor
Type: property
Syntax: set the borderColor of <widget> to <color>
Syntax: get the borderColor of <widget>

Summary: The color of the navigation bar border

Description:
The top border of the navigation bar is drawn using the <borderColor>.

Related: showBorder(property)
*/

-- declaring extension as widget, followed by identifier
widget com.livecode.widget.navbar
--

-- dependancy declarations
use com.livecode.canvas
use com.livecode.widget
use com.livecode.engine
use com.livecode.library.iconsvg
use com.livecode.library.widgetutils
--

-- adding metadata to ensure the extension displays correctly in livecode
metadata author is "LiveCode"
metadata version is "2.0.0"
metadata title is "Navigation Bar"
metadata preferredSize is "320,49"
metadata svgicon is "M0,0v29.5h80.2V0H0z M21.1,21.5c-0.2-0.1-0.4-0.2-0.4-0.2c-0.5-0.2-0.9-0.3-1.4-0.4c-0.7-0.1-0.9-0.4-0.9-1.1c0-0.1-0.1-0.9,0-1c0.4-0.2,0.5-0.9,0.5-1.3c0-0.3,0.2-0.5,0.3-0.7c0.2-0.3,0.2-0.6,0.3-0.9c0.1-0.2,0.2-0.6,0.1-0.8c0-0.2-0.2-0.4-0.2-0.6c0-0.3,0.1-0.6,0.1-0.9c0-0.5,0-0.9,0-1.4c-0.2-1.2-1.4-1.6-2.5-1.9c-1-0.2-2.2,0.3-2.9,1c-0.3,0.3-0.6,0.7-0.7,1.1c-0.1,0.4,0,0.9,0,1.2c0,0.2,0,0.4,0.1,0.6c0,0.2,0.1,0.3,0.1,0.5c0,0.1-0.1,0.2-0.1,0.3c-0.2,0.4,0,1,0.2,1.4c0.1,0.2,0.2,0.4,0.3,0.5c0.2,0.2,0.2,0.3,0.2,0.6c0,0.4,0.1,1.2,0.6,1.4c0.1,0.1,0,0.8-0.1,0.9c0,0.7,0,1-0.6,1.1c-0.5,0.1-0.9,0.2-1.4,0.4c-0.2,0.1-0.4,0.2-0.7,0.3c-2-1.4-3.4-3.8-3.4-6.4c0-4.3,3.5-7.8,7.8-7.8s7.8,3.5,7.8,7.8C24.3,17.8,23,20.1,21.1,21.5z M45.1,22.7l-4.9-3.6v-0.7l0.2,0.2l3.6,2.6L42.6,17l-0.1-0.4l0.3-0.3l3.4-2.5H42h-0.4l-0.1-0.4l-1.4-4.2l-1.4,4.2l-0.1,0.4h-0.4h-4.3l3.4,2.5l0.3,0.3L37.5,17l-1.4,4.2l3.6-2.6l0.2-0.2v0.7L35,22.7l1.9-5.9l-4.9-3.6h6.1l1.9-5.9l1.9,5.9h6.1l-4.9,3.6L45.1,22.7z M71.1,23.1l-4.9-4.9c-1,0.9-2.4,1.4-3.9,1.5V19c3-0.1,5.4-2.5,5.4-5.5c0-3.1-2.5-5.5-5.5-5.5c-3.1,0-5.5,2.5-5.5,5.5c0,3,2.4,5.4,5.4,5.5v0.7c-3.4-0.1-6-2.8-6-6.2c0-3.4,2.8-6.2,6.2-6.2c3.4,0,6.2,2.8,6.2,6.2c0,1.5-0.6,2.9-1.5,4l4.9,4.9L71.1,23.1z"

----------------------------------------------------------------

-- Metadata for re-used engine-level control properties

metadata hiliteColor.editor is "com.livecode.pi.color"
metadata hiliteColor.label is "Selected item color"
metadata hiliteColor.section is "Colors"
metadata hiliteColor.default is "10,95,244"

metadata foregroundColor.editor is "com.livecode.pi.color"
metadata foregroundColor.label is "Item color"
metadata foregroundColor.section is "Colors"
metadata foregroundColor.default is "128,128,128"

metadata backgroundColor.editor is "com.livecode.pi.color"
metadata backgroundColor.label is "Background color"
metadata backgroundColor.section is "Colors"
metadata backgroundColor.default is "244,244,244"

metadata borderColor.editor is "com.livecode.pi.color"
metadata borderColor.label is "Border color"
metadata borderColor.section is "Colors"
metadata borderColor.default is "166,166,166"

----------------------------------------------------------------

/**
Syntax: set the itemArray of <widget> to <array>
Syntax: get the itemArray of <widget>

Summary: The full navigation item data.

Value(array): An array containing all the navigation data.

Description:
The <itemArray> is a numerically keyed array.  Each element of the
array contains an array describing the name, label and icons of the
navigation item at that index.

The <itemArray> can be used to access and modify all of the navigation
data at once, rather than setting the <itemNames>, <itemLabels>,
<itemIcons> and <hilitedItemIcons> individually.

The structure of the <itemArray> is:

```
{ key (integer): The index of the navigation item
	value (array): The array containing the data for the item at this index
	{ key : "label"
		value (string): The label of this item
		key : "name"
		value (string): The name of this item
		key : "icon_name"
		value (string) : The name of the icon to display when the item is not highlighted
		key : "hilited_icon_name"
		value (string) : The name of the icon to display when the item is highlighted
	}
}
```

Any individual keys ("label", "icon_name", "hilited_icon_name") missing when
setting the <itemArray> will be added, and set to their defaults - "circle" for
the icons, and "New Item" for the label.

**Note:** When setting the <itemArray>, an error will be thrown if the
new value is not a numerically-keyed array.

Related: hilitedItemIcons(property), itemIcons(property),
itemLabels(property), itemNames(property)

*/
property itemArray get getNavData set setNavData
metadata itemArray.editor is "com.livecode.pi.navbar"
metadata itemArray.label is "Navigation data"

/**
Syntax: set the itemNames of <widget> to <names>
Syntax: get the itemNames of <widget>
Summary: The names of the navigation items

Value(string): A comma-delimited list of navigation item names.

Description:
The names of the navigation items of the widget.  These are the names
used internally to identify each navigation item, rather than the
<itemLabels> displayed to the user.

Setting the <itemNames> can add or remove items to the navigation bar.

If the new value of the <itemNames> has more items than the navigation
bar, as many new navigation items as necessary are created and added
to the end of the navigation bar, using the default label and icons.

If the new value of the <itemNames> has fewer items than the
navigation bar, items are removed from the end of the navigation bar
as required.

It is not possible to re-order the navigation items by setting the
<itemNames>.

References: itemLabels(property)
*/
property itemNames		get getNavNames			set setNavNames
metadata itemNames.editor is "com.livecode.pi.editorList"
metadata itemNames.subeditor is "com.livecode.pi.string"
metadata itemNames.delimiter is ","
metadata itemNames.label is "Navigation names"

/**
Syntax: set the itemIcons of <widget> to <icons>
Syntax: get the itemIcons of <widget>
Summary: The normal-state icons for the navigation items

Value(string): A comma-delimited list of icon names.

Description:
The names of the icons displayed by the navigation items when not
highlighted.

Each icon name must be one of the predefined graphics provided by the "IconSVG"
library.  You can get a list of available predefined path names by running
`put iconNames()` in the Message Box.

Setting the <itemIcons> can add items to the navigation bar.  If the
new value of the <itemIcons> has more items than the navigation bar,
as many new navigation items as necessary are created and added to the
end of the navigation bar, using a default <itemNames|name>,
<itemLabels|label> and <hilitedItemIcons|highlighted icon>.

If the new value of the <itemIcons> has fewer items than the
navigation bar, the remaining navigation items have their icons reset
to the default icon.

References: hilitedItemIcons(property), itemLabels(property),
itemNames(property)

*/
property itemIcons		get getNavIcons			set setNavIcons
metadata itemIcons.user_visible is "false"

/**
Syntax: set the hilitedItemIcons of <widget> to <icons>
Syntax: get the hilitedItemIcons of <widget>
Summary: The highlighted-state icons for the navigation icons

Value(string): A comma-delimited list of icon names.

Description:
The names of the icons displayed by the navigation items when
highlighted.

Each icon name must be one of the predefined graphics provided by the "IconSVG"
library.  You can get a list of available predefined path names by running
`put iconNames()` in the Message Box.

Setting the <hilitedItemIcons> can add items to the navigation bar.
If the new value of the <hilitedItemIcons> has more items than the
navigation bar, as many new navigation items as necessary are created
and added to the end of the navigation bar, using a default
<itemNames|name>, <itemLabels|label> and <itemIcons|normal icon>.

If the new value of the <hilitedItemIcons> has fewer items than the
navigation bar, the remaining navigation items have their
highlighted-state icons reset to the default icon.

References: itemIcons(property), itemLabels(property), itemNames(property)
*/
property hilitedItemIcons		get getNavSelectedIcons			set setNavSelectedIcons
metadata hilitedItemIcons.user_visible is "false"

/**
Syntax: set the itemLabels of <widget> to <labels>
Syntax: get the itemLabels of <widget>
Summary: The labels of the navigation items

Value(string): A comma-delimited list of labels.

Description:
The display labels for the navigation items of the widget.

Setting the <itemLabels> can add items to the navigation bar.  If the
new value of the <itemLabels> has more items than the navigation bar,
as many new navigation items as necessary are created and added to the
end of the navigation bar, using a default <itemNames|name>,
<itemIcons|icon> and <hilitedItemIcons|highlighted icon>.

If the new value of the <itemLabels> has fewer items than the
navigation bar, the remaining navigation items have their labels reset
to the default icon.

References: hilitedItemIcons (property), itemIcons (property),
itemNames(property)
*/
property itemLabels		get getNavLabels		set setNavLabels
metadata itemLabels.user_visible is "false"

/**
Syntax: set the itemStyle of <widget> to <style>
Syntax: get the itemStyle of <widget>

Summary: The style with which navigation items are displayed

Value(enum): The display style
- "icons": display icons only
- "text": display names only
- "both": display icons and names

Description:
The <itemStyle> property determines whether navigation items are
displayed with icons, with labels, or with icons positioned below
labels.

Related: hilitedItemIcons (property), itemIcons (property),
itemLabels(property)
*/
property itemStyle	get mItemStyle	set setItemStyle
metadata itemStyle.editor is "com.livecode.pi.enum"
metadata itemStyle.options is "icons,text,both"
metadata itemStyle.default is "both"
metadata itemStyle.label is "Display style"


/**
Syntax: set the hilitedItem of <widget> to <itemNumber>
Syntax: get the hilitedItem of <widget>

Summary: The index of the highlighted navigation item

Value(integer): The item number of the navigation item that is highlighted.

Description:
The <hilitedItem> is the item number of the currently-highlighted navigation
item, starting from 1.  It can be used as a key into the <itemArray>.

Related: hilitedItemName (property)

References: itemArray(property)
*/
property hilitedItem	get mSelectedItem 	set setNavSelectedItem
metadata hilitedItem.editor is "com.livecode.pi.integer"
metadata hilitedItem.default is "1"
metadata hilitedItem.label is "Selected item index"
metadata hilitedItem.step is "1"
metadata hilitedItem.min is "1"

/**
Syntax: set the hilitedItemName of <widget> to <pName>
Syntax: get the hilitedItemName of <widget>

Summary: The name of the highlighted navigation item

Value(string): The name of the navigation item that is highlighted.

Description:
The <hilitedItemName> is the name of the currently-highlighted navigation
item.

References: hilitedItem (property)
*/
property hilitedItemName	get getNavSelectedItemName	set setNavSelectedItemName
metadata hilitedItemName.label is "Selected item name"

/**
Syntax: set the editMode of <widget> to {true | false}
Syntax: get the editMode of <widget>

Summary: Whether the widget is in edit mode

Description:
**Note:** This feature is currently **experimental** and may change or
be removed in future versions.

When the <editMode> is enabled, the navigation items' icons can be
changed by clicking on the outlined regions, and new items can be added
with the add button.
*/
property editMode get mEditMode set setEditMode
metadata editMode.user_visible is "false"

/**
Syntax: get the desiredHeight of <widget>

Summary: The optimal height for the widget

Example:
create widget as "com.livecode.widget.navbar"
set the height of it to the desiredHeight of it

Description:
**Note:** This feature is currently **experimental** and may change or
be removed in future versions.

Returns the preferred height for widget, calculated from its current
state.
*/
property desiredHeight	get getDesiredHeight
metadata desiredHeight.user_visible is "false"

/**
Syntax: set the showBorder of <widget> to {true | false}
Syntax: get the showBorder of <widget>

Summary: Whether there is a dividing line at the top of the widget

Description:
When the <showBorder> property is `true`, the navigation bar has a
dividing line along its top edge.

Related: borderColor(property)
*/
property showBorder get mShowDivide set setShowDivide
metadata showBorder.default is "true"
metadata showBorder.label is "Show border"

/**
Name: opaque

Syntax: set the opaque of <widget> to {true | false}
Syntax: get the opaque of <widget>

Summary: Whether the background of the widget is filled

Description:
If the <opaque> property is `true`, the background of the navigation
bar is filled with the <backColor>.  If it is `false` the background
is transparent.

References: backColor(property)
*/
property "opaque" get mShowBackground set setShowBackground
metadata opaque.default is "true"
metadata opaque.label is "Opaque background"

metadata textSize.default is "10"

--

-- private instance variables
private variable mNavData as List

private variable mSelectedItem as Integer
private variable mItemStyle as String

private variable mNavItemCount as Integer
private variable mBoxWidth as Real

private variable mWidth as Real
private variable mHeight as Real

private variable mRecalculate as Boolean

private variable mEditMode as Boolean
private variable mAddIcon as Path
private variable mDeleteIcon as Path
private variable mReorderIcon as Path

private variable mDragData as optional Array

private variable mHiliteColor as Color

private variable mShowDivide as Boolean
private variable mShowBackground as Boolean

private variable mActionPaths as Array

--

constant kIconPaddingRatio is 0.1225
constant kLabelPaddingRatio is 0.06
constant kLabelHeightRatio is 0.165

constant kEditModePaddingUnit is 10
constant kEditModeLineHeight is 50

constant kIconOnlyPaddingRatio is 0.2

constant kDefaultNavName is "new item"
constant kDefaultNavLabel is "New Item"
constant kDefaultNavIconName is "circle"

public handler OnSave(out rProperties as Array)
	put the empty array into rProperties

	put getNavData() into rProperties["items"]
	put mSelectedItem into rProperties["selected"]
	put mItemStyle into rProperties["itemStyle"]
	put mShowDivide into rProperties["showBorder"]
	put mShowBackground into rProperties["opaque"]
end handler

public handler OnLoad(in pProperties as Array)
	setNavData(pProperties["items"])
	put pProperties["selected"] into mSelectedItem
	setItemStyle(pProperties["itemStyle"])

	if "showBorder" is among the keys of pProperties then
		put pProperties["showBorder"] into mShowDivide
	else
		put true into mShowDivide
	end if

	if "opaque" is among the keys of pProperties then
		put pProperties["opaque"] into mShowBackground
	else
		put true into mShowBackground
	end if
end handler

public handler OnCreate() returns nothing
	-- creating a list of navigation items

	variable tNavItems as List
	put the empty list into tNavItems

	variable tArray as Array
	put the empty array into tArray

	put "contacts" into tArray["name"]
	put "Contacts" into tArray["label"]
	put "user" into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	push tArray onto tNavItems

	put "favourites" into tArray["name"]
	put "Favourites" into tArray["label"]
	put "star empty" into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	push tArray onto tNavItems

	put "music" into tArray["name"]
	put "Music" into tArray["label"]
	put "music" into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	push tArray onto tNavItems

	put "search" into tArray["name"]
	put "Search" into tArray["label"]
	put "search" into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	push tArray onto tNavItems
	put the number of elements in tNavItems into mNavItemCount

	put tNavItems into mNavData

	put 1 into mSelectedItem
	put nothing into mDragData
	put "both" into mItemStyle

	put 0 into mBoxWidth

	initialiseEditData()

	put true into mRecalculate
	put false into mEditMode

	put path iconSVGPathFromName("plus") into mAddIcon
	put path iconSVGPathFromName("minus sign") into mDeleteIcon
	put path iconSVGPathFromName("reorder") into mReorderIcon

	put color [0, 121/255,1] into mHiliteColor

	put true into mShowDivide
	put true into mShowBackground

	put the empty array into mActionPaths
end handler

public handler OnPaint() returns nothing

	if mRecalculate then
		updateParameters()
	end if

	if not mEditMode then
		drawNavBar()
	else
		drawNavBarEditMode()
	end if
end handler

----------------------------------------------------------------
-- Drawing in normal mode
----------------------------------------------------------------

private handler drawNavBar() returns nothing
	-- background
	if mShowBackground then
		set the paint of this canvas to my background paint
		fill getPath("background") on this canvas
	end if

	if mNavItemCount is not 0 then
		drawNavBarContent()
	end if

	-- Draw the top line
	if mShowDivide then
		set the paint of this canvas to my border paint
		set the stroke width of this canvas to 0
		stroke getPath("line") on this canvas
	end if
end handler

private handler drawNavBarContent() returns nothing
	variable tX as Integer
	repeat with tX from 1 up to mNavItemCount
		-- Draw the text of the nav bar
		if mItemStyle is in ["text","both"] then
			drawLabel(mNavData[tX]["label"], mNavData[tX]["label_rect"], tX is mSelectedItem)
		end if

		if mItemStyle is in ["icons","both"] then
			-- Draw the icon
			if tX is mSelectedItem then
				drawIcon(mNavData[tX]["hilited_icon_path"], true)
			else
				drawIcon(mNavData[tX]["icon_path"], false)
			end if

		end if
	end repeat
end handler

----------------------------------------------------------------
-- Drawing in edit mode
----------------------------------------------------------------

private handler drawNavBarEditMode() returns nothing
	// Make sure the subsequent drawing operations are opaque
	set the opacity of this canvas to 1
	// background
	set the paint of this canvas to getPaint("background","editmode-fill")
	fill getPath("bounding box") on this canvas

	set the paint of this canvas to getPaint("background","editmode-stroke")
	set the stroke width of this canvas to 0
	stroke getPath("bounding box") on this canvas

	if mNavItemCount is 0 then
		set the paint of this canvas to getPaint("add", "fill")
		fill mActionPaths["add_icon_path"] on this canvas
	else
		drawEditModeContent()
	end if
end handler

private handler drawEditModeContent() returns nothing
	variable tX as Integer
	repeat with tX from 1 up to mNavItemCount
			-- Draw the text of the nav bar
			drawEditModeLabel(mNavData[tX]["label"], mNavData[tX]["label_rect"])
			-- Draw the icon
			drawIcon(mNavData[tX]["icon_path"], false)
			-- Draw the selectedIcon
			drawIcon(mNavData[tX]["hilited_icon_path"], true)
			-- Draw the 'add item' item
			drawActionItems(tX)
			-- Draw the rects round the editable elements
			--drawEditableRects(this canvas)
			-- Draw the line between items
			drawEditModeDivide(tX)
	end repeat

	if mDragData is not nothing then
		drawDragData()
	end if
end handler

private handler drawDragData()
	if mDragData is nothing then
		return
	end if

	variable tTargetPath as Path
	if "target" is among the keys of mDragData then
		if mDragData["target"] is 0 then
			put line path from point [0, mDragData["target"] * kEditModeLineHeight + 2] to point [mWidth, mDragData["target"] * kEditModeLineHeight + 2] into tTargetPath
		else if mDragData["target"] is mNavItemCount then
			put line path from point [0, mDragData["target"] * kEditModeLineHeight - 2] to point [mWidth, mDragData["target"] * kEditModeLineHeight - 2] into tTargetPath
		else
			put line path from point [0, mDragData["target"] * kEditModeLineHeight] to point [mWidth, mDragData["target"] * kEditModeLineHeight] into tTargetPath
		end if

		set the paint of this canvas to getPaint("text", "selected-fill")
		set the stroke width of this canvas to 3
		stroke tTargetPath on this canvas
	end if

	if "rect" is among the keys of mDragData then
		set the opacity of this canvas to 0.4
		set the paint of this canvas to getPaint("background","drag-fill")
		fill rectangle path of mDragData["rect"] on this canvas
		-- Draw the text of the nav bar
		drawEditModeLabel(mDragData["label"], mDragData["label_rect"])
		-- Draw the icon
		drawIcon(mDragData["icon_path"], false)
		-- Draw the selectedIcon
		drawIcon(mDragData["hilited_icon_path"], true)
	end if
end handler

private handler drawEditModeDivide(in pNumber as Number) returns nothing
	if pNumber is mNavItemCount then
		return
	end if
	variable tPath as Path
	put line path from point [1, kEditModeLineHeight * pNumber] to point [mWidth - 1, kEditModeLineHeight * pNumber + 1] into tPath
	set the paint of this canvas to my border paint
	set the stroke width of this canvas to 0
	stroke tPath on this canvas
end handler

private handler drawIcon(in pIconPath as Path, in pSelected as Boolean)
	if pSelected then
		set the paint of this canvas to my highlight paint
	else
		set the paint of this canvas to my foreground paint
	end if

	fill pIconPath on this canvas
end handler

private handler drawLabel(in pLabel as String, in pRect as Rectangle, in pSelected as Boolean)
	if pSelected then
		set the paint of this canvas to my highlight paint
	else
		set the paint of this canvas to my foreground paint
	end if

	set the font of this canvas to getFont("label")
	fill text pLabel at center of pRect on this canvas
end handler

private handler drawEditModeLabel(in pLabel as String, in pRect as Rectangle)
	set the paint of this canvas to getPaint("text","editmode-fill")
	set the font of this canvas to getFont("editmode-label")
	fill text pLabel at left of pRect on this canvas
end handler

constant kStandardActions is ["add","delete","reorder"]
private handler drawActionItems(in pRow as Integer)
	drawActionItemsList(kStandardActions, pRow)
end handler

private handler drawActionItemsList(in pActions as List, in pRow as Integer)
	variable tIconPath as Path
	variable tElement as String
	repeat for each element tElement in pActions
		-- Draw the item
		set the paint of this canvas to getPaint(tElement, "fill")
		put mNavData[pRow][tElement & "_icon_path"] into tIconPath
		fill tIconPath on this canvas
	end repeat
end handler

public handler OnMouseUp() returns nothing
	variable tClickPos as Point
	put the click position into tClickPos
	if mEditMode then
		-- Dismiss the transient fields when the widget is clicked
		post "dismissTransient"
		widgetClicked(tClickPos, true)
	end if
end handler

public handler OnMouseDown() returns nothing
	variable tClickPos as Point
	put the click position into tClickPos
	if mEditMode then
		widgetClicked(tClickPos, false)
	else
		variable tSelected as Number
		put locToNavItem(tClickPos) into tSelected

		if tSelected > 0 then
			put tSelected into mSelectedItem
			redraw all

			variable tItemLabel as String
			put mNavData[mSelectedItem]["label"] into tItemLabel
			post "hiliteChanged"
		end if
	end if
end handler

public handler OnMouseMove() returns nothing
		if mDragData is not nothing then
			calculateDragRow(the y of the mouse position)
			redraw all
			return
		end if

		if mEditMode then
			updateEditModeTooltip(the mouse position)
			return
		end if
end handler

private handler updateParameters()
	initialiseEditData()

	// update variables
	put my width into mWidth
	put my height into mHeight
	put the number of elements in mNavData into mNavItemCount

	if mNavItemCount is 0 then
		put mWidth into mBoxWidth
	else
		put mWidth / mNavItemCount into mBoxWidth
	end if

	if mEditMode then
		if mNavItemCount is 0 then
			calculateAddItemRect()
		else
			calculateEditModeIconRects()
		end if
	else if mNavItemCount is not 0 then
		calculateIconRects()
	end if
	put false into mRecalculate
end handler

private handler updateEditModeTooltip(in pPosition as Point) returns nothing
    variable tElement as Array
	repeat for each element tElement in mEditData
		if pPosition is within tElement["rect"] then
			if "tooltip" is among the keys of tElement then
				set property "tooltip" of my script object to tElement["tooltip"]
				return
			end if
		end if
	end repeat

	set property "tooltip" of my script object to ""
end handler

private handler calculateEditModeIconRects() returns nothing
	// calculate the drawing rects
	variable tX as Integer
	variable tIconPath as Path
	variable tIconRect as Rectangle
	variable tLineHeight as Real
	put kEditModeLineHeight into tLineHeight

	repeat with tX from 1 up to mNavItemCount
		variable tLabelLeft as Real
		variable tLabelRight as Real

		variable tLineTop as Real
		variable tLineBottom as Real
		put (tX - 1) * tLineHeight into tLineTop
		put tX * tLineHeight into tLineBottom

		-- One 1/2 line height icon + 2 lots of padding gives width of data to left of label
		put 2 * kEditModePaddingUnit + tLineHeight / 4 into tLabelLeft
		-- Two 1/4 line height icons + two line height icons + 4 lots of padding gives width of data to right of label
		put mWidth - (4 * kEditModePaddingUnit + 5 * tLineHeight / 2) into tLabelRight

		put rectangle [tLabelLeft, tLineTop + kEditModePaddingUnit, tLabelRight, tLineBottom - kEditModePaddingUnit] into mNavData[tX]["label_rect"]
		-- Allow label to be edited inline
		setEditableTextRect("label", tX, mNavData[tX]["label_rect"], "Label")

		if mNavData[tX]["icon_name"] is not empty then
			put iconSVGPathFromName(mNavData[tX]["icon_name"]) into mNavData[tX]["icon"]
		end if
		put path mNavData[tX]["icon"] into tIconPath

		variable tLeft as Real
		put tLabelRight + kEditModePaddingUnit into tLeft

		put rectangle [tLeft + kEditModePaddingUnit, tLineTop + kEditModePaddingUnit, tLeft + tLineHeight - kEditModePaddingUnit, tLineBottom - kEditModePaddingUnit] into tIconRect
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mNavData[tX]["icon_path"]
		put tIconRect into mNavData[tX]["icon_rect"]

		if mNavData[tX]["hilited_icon_name"] is not empty then
			put iconSVGPathFromName(mNavData[tX]["hilited_icon_name"]) into mNavData[tX]["hilited_icon"]
		end if

		if mNavData[tX]["hilited_icon"] is not "" then
			put path mNavData[tX]["hilited_icon"] into tIconPath
		end if

		add tLineHeight to tLeft
		put rectangle [tLeft + kEditModePaddingUnit, tLineTop + kEditModePaddingUnit, tLeft + tLineHeight - kEditModePaddingUnit, tLineBottom - kEditModePaddingUnit] into tIconRect
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mNavData[tX]["hilited_icon_path"]
		put tIconRect into mNavData[tX]["hilited_icon_rect"]

		setEditableRect("icon", tX, mNavData[tX]["icon_rect"], \
				"Icon", "com.livecode.widget.iconPicker", iconSelected)
		setEditableRect("selectedIcon", tX, mNavData[tX]["hilited_icon_rect"], \
				"Highlighted Icon", "com.livecode.widget.iconPicker", iconSelected)

		calculateEditModeActionPathsForRow(tX)
	end repeat
end handler

private handler calculateAddItemRect()
	calculateEditModeActionIconPaths(["add"])
	setActionRect("add_icon", 1, \
			the bounding box of mActionPaths["add_icon_path"], "Add Item", \
			addItem, true)
end handler

private handler calculateEditModeActionPathsForRow(in pRow as Integer)
	calculateEditModeActionIconPaths(kStandardActions)

	variable tIconPath as Path
	put mActionPaths["add_icon_path"] into tIconPath
	translate tIconPath by [0, (pRow - 1) * kEditModeLineHeight]
	put tIconPath into mNavData[pRow]["add_icon_path"]
	setActionRect("add_icon", pRow, the bounding box of tIconPath, \
			"Add Item", addItem, true)

	put mActionPaths["delete_icon_path"] into tIconPath
	translate tIconPath by [0, (pRow - 1) * kEditModeLineHeight]
	put tIconPath into mNavData[pRow]["delete_icon_path"]
	setActionRect("delete_icon", pRow, the bounding box of tIconPath, \
			"Delete Item", deleteItem, true)

	put mActionPaths["reorder_icon_path"] into tIconPath
	translate tIconPath by [0, (pRow - 1) * kEditModeLineHeight]
	put tIconPath into mNavData[pRow]["reorder_icon_path"]
	setActionRect("reorder_icon", pRow, the bounding box of tIconPath, \
			"Reposition Item", reorderItem, false)

end handler

private handler calculateEditModeActionIconPaths(in pActions as List)
	variable tIconPath as Path
	variable tIconRect as Rectangle

	variable tActionFraction as Real
	put 1/4 into tActionFraction

	variable tLeft as Real
	variable tTop as Real
	variable tRight as Real
	variable tBottom as Real
	put my width - 2 * (kEditModeLineHeight * tActionFraction + kEditModePaddingUnit) into tLeft
	put kEditModeLineHeight * (1 - tActionFraction) / 2 into tTop
	put tLeft + kEditModeLineHeight * tActionFraction into tRight
	put kEditModeLineHeight - kEditModeLineHeight * (1 - tActionFraction) / 2 into tBottom

	if "add" is in pActions then
		put rectangle [tLeft, tTop, tRight, tBottom] into tIconRect
		put mAddIcon into tIconPath
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mActionPaths["add_icon_path"]
	end if

	if "reorder" is in pActions then
		add kEditModeLineHeight * tActionFraction + kEditModePaddingUnit to tLeft
		put tLeft + kEditModeLineHeight * tActionFraction into tRight
		put rectangle [tLeft, tTop, tRight, tBottom] into tIconRect
		put mReorderIcon into tIconPath
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mActionPaths["reorder_icon_path"]
	end if

	if "delete" is in pActions then
		put rectangle [kEditModePaddingUnit, tTop, kEditModePaddingUnit + kEditModeLineHeight * tActionFraction, tBottom] into tIconRect
		put mDeleteIcon into tIconPath
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mActionPaths["delete_icon_path"]
	end if
end handler

private handler calculateDragRow(in pY as Real) returns nothing
	variable tLineHeight as Real
	put kEditModeLineHeight into tLineHeight

	-- calculate the drag destination
	put the floor of ((pY + tLineHeight / 2) / tLineHeight) into mDragData["target"]

	variable tLabelLeft as Real
	variable tLabelRight as Real

	variable tLineTop as Real
	variable tLineBottom as Real
	put pY - mDragData["offset"] into tLineTop
	put tLineTop + tLineHeight  into tLineBottom

	-- calculate the drawing rects
	put rectangle [0, tLineTop, mWidth, tLineBottom] into mDragData["rect"]

	-- One 1/2 line height icon + 2 lots of padding gives width of data to left of label
	put 2 * kEditModePaddingUnit + tLineHeight / 4 into tLabelLeft
	-- Two 1/4 line height icons + two line height icons + 4 lots of padding gives width of data to right of label
	put mWidth - (4 * kEditModePaddingUnit + 5 * tLineHeight / 2) into tLabelRight

	put rectangle [tLabelLeft, tLineTop + kEditModePaddingUnit, tLabelRight, tLineBottom - kEditModePaddingUnit] into mDragData["label_rect"]

	variable tIconPath as Path
	variable tIconRect as Rectangle
	put path mNavData[mDragData["item"]]["icon"] into tIconPath

		variable tLeft as Real
		put tLabelRight + kEditModePaddingUnit into tLeft

		put rectangle [tLeft + kEditModePaddingUnit, tLineTop + kEditModePaddingUnit, tLeft + tLineHeight - kEditModePaddingUnit, tLineBottom - kEditModePaddingUnit] into tIconRect
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mDragData["icon_path"]

		if mNavData[mDragData["item"]]["hilited_icon"] is not "" then
			put path mNavData[mDragData["item"]]["icon"] into tIconPath
		end if

		add tLineHeight to tLeft
		put rectangle [tLeft + kEditModePaddingUnit, tLineTop + kEditModePaddingUnit, tLeft + tLineHeight - kEditModePaddingUnit, tLineBottom - kEditModePaddingUnit] into tIconRect
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mDragData["hilited_icon_path"]
end handler

private handler calculateIconRects() returns nothing
	variable tNumItems as Number
	variable tIdx as Number
	variable tXOffset as Number
	variable tYOffset as Number
	variable tIconName as String
	variable tIconPadding as Number
	variable tIconRectInfo as List
	variable tLabelRectInfo as List
	variable tIconRect as Rectangle
	variable tLabelRect as Rectangle
	variable tIconType as String
	variable tIconPath as Path

	put the number of elements in mNavData into tNumItems

	repeat with tIdx from 1 up to tNumItems

		-- Compute vertical centreline for text and icon
		put mBoxWidth * (tIdx - 0.5) into tXOffset

		-- Compute label rect
		if mItemStyle is "text" then
			-- Each label's effective rect is the whole of the item's box
			put [tXOffset - mBoxWidth / 2, 0, \
					tXOffset + mBoxWidth / 2, my height] into tLabelRectInfo

		else
			-- Each label is located below the corresponding icon
			put [tXOffset - mBoxWidth / 2, \
					my height * (1 - kLabelPaddingRatio - kLabelHeightRatio), \
					tXOffset + mBoxWidth / 2, \
					my height * (1 - kLabelPaddingRatio)] into tLabelRectInfo
		end if

		put rectangle tLabelRectInfo into tLabelRect
		put tLabelRect into mNavData[tIdx]["label_rect"]

		if mItemStyle is "text" then
			-- Don't need to process icons
			next repeat
		end if

		-- Compute icon rect

		if mItemStyle is "icons" then
			-- Position icons along horizontal centreline
			put my height * kIconOnlyPaddingRatio into tIconPadding
			put [tXOffset - (mBoxWidth/2), \
					tIconPadding, \
					tXOffset + (mBoxWidth/2), \
					my height - tIconPadding] into tIconRectInfo
		else
			-- Position icons above text
			put my height * kIconPaddingRatio into tIconPadding
			put [tXOffset - (mBoxWidth/2), \
					tIconPadding, \
					tXOffset + (mBoxWidth/2), \
					the top of tLabelRect - tIconPadding] into tIconRectInfo
		end if

		put rectangle tIconRectInfo into tIconRect

		-- Fit icons into the icon rect.  Repeat twice, once for the "normal"
		-- icon and once for the "hilited" icon.  Note that we carry the "normal"
		-- path round to become the "hilited" icon if there's no "hilited" icon
		-- specified.
		put the empty path into tIconPath
		repeat for each element tIconType in ["icon","hilited_icon"]
			-- Update icon path
			if mNavData[tIdx][tIconType & "_name"] is not empty then
				put iconSVGPathFromName(mNavData[tIdx][tIconType & "_name"]) \
					into mNavData[tIdx][tIconType]
			else
				put "" into mNavData[tIdx][tIconType]
			end if

			-- Fit the icon path to the icon rect
			if mNavData[tIdx][tIconType] is not empty then
				-- Fit icon path to Rectangle
				put path mNavData[tIdx][tIconType] into tIconPath
				constrainPathToRect(tIconRect, tIconPath)
			end if

			put tIconPath into mNavData[tIdx][tIconType & "_path"]
			put tIconRect into mNavData[tIdx][tIconType & "_rect"]
		end repeat
	end repeat
end handler

public handler OnGeometryChanged()
	put true into mRecalculate
end handler

--Callback when an icon is selected from the icon picker widget
public handler iconSelected(in pSelectedIcon as optional any, in pType as String, in pNumber as Number)
	if pSelectedIcon is not nothing then
		if pType is "selectedIcon" then
			put pSelectedIcon into mNavData[pNumber]["hilited_icon_name"]
			put "" into mNavData[pNumber]["hilited_icon"]
		else
			put pSelectedIcon into mNavData[pNumber]["icon_name"]
			put "" into mNavData[pNumber]["icon"]
		end if

		-- If the selected icon is the same as the icon, just put empty into the selected icon name
		-- that way, when the icon is changed, the selected icon will change too.
		if mNavData[pNumber]["hilited_icon_name"] is mNavData[pNumber]["icon_name"] then
			put "" into mNavData[pNumber]["hilited_icon_name"]
			put "" into mNavData[pNumber]["hilited_icon"]
		end if
		post "dataChanged"
		put true into mRecalculate
		redraw all
	end if
end handler

private handler clickPosToComponent(in pClickPos as Point) returns Integer
	variable tX as Integer
	repeat with tX from 1 up to mNavItemCount
		variable tIconRect as Rectangle
    	put mNavData[tX]["icon_rect"] into tIconRect
		if pClickPos is within tIconRect then
			return tX
		end if
	end repeat

	return 0
end handler

private handler locToNavItem(in pLoc as Point) returns Integer
	return the floor of (the x of pLoc / mBoxWidth) + 1
end handler

private handler yPosToLine(in pY as Number) returns Integer
	variable tLineHeight as Real
	put mHeight / mNavItemCount into tLineHeight
	return the floor of (pY / tLineHeight) + 1
end handler

public handler setHiliteColor(in pColor as String) returns nothing
	put stringToColor(pColor) into mHiliteColor
	redraw all
end handler

public handler getHiliteColor() returns String
	return colorToString(mHiliteColor, false)
end handler

public handler getPath(in pObject as String) returns Path
	variable tRect
	put my bounds into tRect
	if pObject is "bounding box" then
		return rectangle path of rectangle [the left of tRect + 0.5, the top of tRect + 0.5, the right of tRect - 0.5, the bottom of tRect - 0.5]
	else if pObject is "line" then
		return line path from point [0, 0.5] to point [my width, 0.5]
		-- Offset background by 1 from the top so that line is allowed to be transparent
	else if pObject is "background" then
		return rectangle path of rectangle [the left of tRect + 0.5, the top of tRect + 1, the right of tRect - 0.5, the bottom of tRect - 0.5]
	end if
end handler

public handler getPaint(pLocation, pType) returns Paint
	if pLocation is "background" then
		if pType is "drag-fill" then
			return solid paint with color [200/255, 200/255, 200/255]
		else if pType is "stroke" then
			return solid paint with color [0, 0, 0, 0.2]
		else if pType is "editmode-stroke" then
			return solid paint with color [193/255, 193/255, 193/255]
		else if pType is "editmode-fill" then
			return solid paint with color [1, 1, 1]
		end if
	else if pLocation is "text" then
		if pType is "fill" then
			return solid paint with color [146/255, 146/255, 146/255]
		else if pType is "selected-fill" then
			return solid paint with mHiliteColor
		else if pType is "additem" or pType is "deleteitem" then
			return solid paint with color [1, 1, 1]
		else if pType is "editmode-fill" then
			return solid paint with color [0, 0, 0]
		end if
	end if

	if pLocation is "add" then
		return solid paint with color [146/255, 146/255, 146/255]
	else if pLocation is "reorder" then
		return solid paint with color [146/255, 146/255, 146/255]
	else if pLocation is "delete" then
		return solid paint with color [240/255, 0, 0]
	end if

	return solid paint with color [1, 100/255, 200/255]
end handler

private handler getFont(in pType as String) returns Font
	return my font
end handler

public handler setNavSelectedItem(in pSelectedItem as Integer) returns nothing
	if pSelectedItem is not mSelectedItem and \
			pSelectedItem > 0 and \
			pSelectedItem <= the number of elements in mNavData then
		put pSelectedItem into mSelectedItem
		post "hiliteChanged"
		redraw all
	end if
end handler

public handler setNavSelectedItemName(in pName as String) returns nothing
	variable tCount as Integer
	variable tItem as Array
	
	-- Find the item index corresponding to pName and set it as the
	-- currently-highlighted item.
	
	repeat with tCount from 1 up to the number of elements in mNavData
		put mNavData[tCount] into tItem
		if tItem["name"] is pName then
			setNavSelectedItem(tCount)
			exit repeat
		end if
	end repeat

end handler

public handler getNavSelectedItemName() returns String
	return mNavData[mSelectedItem]["name"]
end handler

public handler setItemStyle(in pItemStyle as String) returns nothing
	-- Cope with old-style item style property values
	if pItemStyle is "icons and names" then
		put "both" into pItemStyle
	end if
	if pItemStyle is "names" then
		put "text" into pItemStyle
	end if

	put pItemStyle into mItemStyle
	put true into mRecalculate
	redraw all
end handler

public handler setEditMode(in pEditMode as Boolean) returns nothing
	put pEditMode into mEditMode

	put true into mRecalculate
	redraw all
end handler

--------------------------------------------------------------------------------
--
--		Data utilities
--
--------------------------------------------------------------------------------

private handler listToArray(in pList as List) returns Array
	variable tCount
	variable tArray
	put the empty array into tArray

	variable tKey as String
	repeat with tCount from 1 up to the number of elements in pList
		put tCount formatted as string into tKey
		put defaultNavArray() into tArray[tKey]

		variable tAttribute as String
		repeat for each key tAttribute in tArray[tKey]
			put pList[tCount][tAttribute] into tArray[tKey][tAttribute]
		end repeat
	end repeat
	return tArray
end handler

private handler setData(in pArray as Array, in pKeys as List, out rList as List)
	-- Excessive hoop-jumping to work around the fact that keys of numerically keyed LCS array
	-- comes into LCB as strings, and therefore must be parsed as number to sort, then formatted back
	-- to be used as keys again. Because parse/format of integer doesn't currently roundtrip, we need to
	-- create a lookup from the original strings.
	variable tKey
	variable tOrder as List
	put the empty list into tOrder
	variable tLookup as Array
	put the empty array into tLookup
	variable tNumericKey as Number
	repeat for each key tKey in pArray
		put tKey parsed as number into tNumericKey
		push tNumericKey onto tOrder
		put tKey into tLookup[tNumericKey formatted as string]
	end repeat
	sort tOrder in ascending numeric order

	variable tOrderKey
	variable tElement as Array
	variable tList as List
	put the empty list into tList

	variable tOriginalKey as String
	repeat for each element tOrderKey in tOrder
		put the empty array into tElement
		repeat for each element tKey in pKeys
			put tLookup[tOrderKey formatted as string] into tOriginalKey
			-- Use default item if key is not present
			if tKey is among the keys of pArray[tOriginalKey] then
				put pArray[tOriginalKey][tKey] into tElement[tKey]
			else
				put defaultNavElement(tKey) into tElement[tKey]
			end if
		end repeat
		if tElement["label"] is "" then
			put "New Item" into tElement["label"]
		end if
		-- If the selected icon is the same as the icon, just put empty into the selected icon name
		-- that way, when the icon is changed, the selected icon will change too.
		if tElement["hilited_icon_name"] is tElement["icon_name"] then
			put "" into tElement["hilited_icon_name"]
		end if
		push tElement onto tList
	end repeat

	put tList into rList
end handler

private handler getDataElement(in pElementName as String, in pList as List) returns String
	variable tList
	put the empty list into tList

	variable tElement
	repeat for each element tElement in pList
		push tElement[pElementName] onto tList
	end repeat

	variable tElements
	combine tList with "," into tElements
	return tElements
end handler

private handler setDataElement(in pElementName as String, in pElements as String, in pDefaultArray as Array, inout xList as List)
	variable tElements
	split pElements by "," into tElements

	variable tCount
	put 0 into tCount

	variable tElement
	repeat for each element tElement in xList
		add 1 to tCount
		if tCount > the number of elements in tElements then
			put pDefaultArray[pElementName] into xList[tCount][pElementName]
		else
			put tElements[tCount] into xList[tCount][pElementName]
		end if
	end repeat

	// If we there are more of the given element than there are items, generate more
	add 1 to tCount
	repeat with tCount from tCount up to the number of elements in tElements
		push pDefaultArray onto xList
		put tElements[tCount] into xList[tCount][pElementName]
	end repeat

	put true into mRecalculate
    post "navDataChanged"
	redraw all
end handler

-- Only the primary data element ("name" for both actions and nav) can *reduce*
-- the number of elements in the data list.
private handler setPrimaryDataElement(in pElementName as String, \
		in pElements as String, in pUnique as Boolean, \
		in pDefaultArray as Array, inout xList as List)
	variable tElements as List
	variable tElement as String
	variable tCount as Number

	split pElements by "," into tElements

	-- Enforce uniqueness, if requested
	if pUnique then
		put 0 into tCount
		repeat with tCount from 1 up to the number of elements in tElements
			if the index of tElements[tCount] after tCount in tElements is not 0 then
				throw "duplicate" && pElementName && tElements[tCount]
				return
			end if
		end repeat
	end if

	put 0 into tCount
	repeat for each element tElement in tElements
		add 1 to tCount
		if tCount > the number of elements in xList then
			push pDefaultArray onto xList
		end if

		put tElement into xList[tCount][pElementName]
	end repeat

	// If we there are more items than there are primary elements, pop them off.
	add 1 to tCount
	repeat with tCount from tCount up to the number of elements in xList
		pop xList
	end repeat

	put true into mRecalculate
    post "dataChanged"
	redraw all
end handler

--------------------------------------------------------------------------------
--
--		Nav data handling
--
--------------------------------------------------------------------------------

private handler defaultNavElement(in pKey as String) returns String
	if pKey is "name" then
		return kDefaultNavName
	else if pKey is "label" then
		return kDefaultNavLabel
	else if pKey is "icon_name" then
		return kDefaultNavIconName
	else if pKey is "hilited_icon_name" then
		return ""
	else if pKey is "icon" then
		return ""
	else if pKey is "hilited_icon" then
		return ""
	end if
	return ""
end handler

private handler defaultNavArray() returns Array
	variable tArray as Array
	put the empty array into tArray
	put kDefaultNavName into tArray["name"]
	put kDefaultNavLabel into tArray["label"]
	put kDefaultNavIconName into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	return tArray
end handler

private handler navDataDifferent(in pLeft as List, in pRight as List) returns Boolean
    if the number of elements in pLeft is not the number of elements in pRight then
        return true
    end if

	variable tIndex as Number
	repeat with tIndex from 1 up to the number of elements in pLeft
        if pLeft[tIndex]["label"] is not pRight[tIndex]["label"] then
            return true
        end if

        if pLeft[tIndex]["icon_name"] is not pRIght[tIndex]["icon_name"] then
            return true
        end if

        if pLeft[tIndex]["hilited_icon_name"] is not pRight[tIndex]["hilited_icon_name"] then
            if not (pLeft[tIndex]["hilited_icon_name"] is "" and pRight[tIndex]["hilited_icon_name"] is pRight[tIndex]["icon_name"]) and not (pLeft[tIndex]["hilited_icon_name"] is pLeft[tIndex]["icon_name"] and pRight[tIndex]["hilited_icon_name"] is "") then
                return true
            end if
        end if
	end repeat
	return false
end handler

private handler getNavData() returns Array
	return listToArray(mNavData)
end handler

private handler setNavData(in pNavData as Array)
	variable tNavData as List
	setData(pNavData, the keys of defaultNavArray(), tNavData)
	if navDataDifferent(tNavData, mNavData) then
		put tNavData into mNavData
		put true into mRecalculate
		post "dataChanged"
		redraw all
	end if
end handler

private handler getNavNames() returns String
	return getDataElement("name", mNavData)
end handler

private handler setNavNames(in pNames as String)
	setPrimaryDataElement("name", pNames, true, defaultNavArray(), mNavData)
end handler

private handler getNavIcons() returns String
	return getDataElement("icon_name", mNavData)
end handler

private handler setNavIcons(in pIcons as String)
	setDataElement("icon_name", pIcons, defaultNavArray(), mNavData)
end handler

private handler getNavSelectedIcons() returns String
	return getDataElement("hilited_icon_name", mNavData)
end handler

private handler setNavSelectedIcons(in pIcons as String)
	setDataElement("hilited_icon_name", pIcons, defaultNavArray(), mNavData)
end handler

private handler getNavLabels() returns String
	return getDataElement("label", mNavData)
end handler

private handler setNavLabels(in pLabels as String)
	setDataElement("label", pLabels, defaultNavArray(), mNavData)
end handler

private handler addItem(in pItem as Number)
	if mNavData is [] then
		push defaultNavArray() onto mNavData
	else
		splice [defaultNavArray()] after element pItem of mNavData
	end if
	put true into mRecalculate
	post "dataChanged"
	redraw all
end handler

private handler deleteItem(in pItem as Number)
	delete element pItem of mNavData
	put true into mRecalculate
	post "dataChanged"
	redraw all
end handler

private handler moveItem(in pFrom as Number, in pTo as Number) returns nothing
	-- Do nothing if this isn't really a move.
	if pFrom is pTo then
		return
	end if

	variable tItem as Array
	put mNavData[pFrom] into tItem
	delete element pFrom of mNavData
	if pTo is 1 then
		splice [tItem] before element 1 of mNavData
	else
		splice [tItem] after element (pTo - 1) of mNavData
	end if
	post "dataChanged"
	put true into mRecalculate
end handler

private handler reorderItem(in pItem as Number)
	put {} into mDragData
	put the y of the mouse position - ((pItem - 1) * kEditModeLineHeight) into mDragData["offset"]
	put pItem into mDragData["item"]
	put mNavData[pItem]["label"] into mDragData["label"]
	redraw all
end handler

private handler dragDrop() returns nothing
	if mDragData is nothing then
		return
	end if

	if "target" is among the keys of mDragData then
		if mDragData["item"] > mDragData["target"] then
			moveItem(mDragData["item"], mDragData["target"] + 1)
		else if mDragData["target"] > mDragData["item"] then
			moveItem(mDragData["item"], mDragData["target"])
		end if
		put nothing into mDragData
		redraw all
	end if
end handler

private handler getDesiredHeight() returns Number
	if mEditMode and mNavItemCount is not 0 then
		return kEditModeLineHeight * mNavItemCount
	end if

    return kEditModeLineHeight
end handler

private handler setShowDivide(in pShowDivide as Boolean) returns nothing
	if pShowDivide is mShowDivide then
		return
	end if

	put pShowDivide into mShowDivide
	redraw all
end handler

private handler setShowBackground(in pShowBackground as Boolean) returns nothing
	if pShowBackground is mShowBackground then
		return
	end if

	put pShowBackground into mShowBackground
	redraw all
end handler

--------------------------------------------------------------------------------
--
--		Editable rect things
--
--------------------------------------------------------------------------------

handler type PopupCallback(in pPopupResult as optional any, in pType as String, in pNumber as Number)
handler type ActionCallback(in pNumber as Number)

private variable mEditData as Array

public handler initialiseEditData()
	put the empty array into mEditData
end handler

public handler setEditableRect(in pComponent as String, in pNumber as Number, \
		in pRect as Rectangle, in pTooltip as String, in pPopup as String, \
		in pCallback as PopupCallback)
	variable tComponentID as String
	put pComponent && pNumber formatted as string into tComponentID

	put the empty array into mEditData[tComponentID]

	put pRect into mEditData[tComponentID]["rect"]
	put pTooltip into mEditData[tComponentID]["tooltip"]
	put pPopup into mEditData[tComponentID]["popup"]
	put pCallback into mEditData[tComponentID]["callback"]
	put pComponent into mEditData[tComponentID]["type"]
	put pNumber into mEditData[tComponentID]["number"]
	put true into mEditData[tComponentID]["mouseup"]
end handler

public handler setEditableTextRect(in pComponent as String, \
		in pNumber as Number, in pRect as Rectangle, in pTooltip as String)
	variable tComponentID as String
	put pComponent && pNumber formatted as string into tComponentID

	put the empty array into mEditData[tComponentID]

	put pRect into mEditData[tComponentID]["rect"]
	put pTooltip into mEditData[tComponentID]["tooltip"]
	put pComponent into mEditData[tComponentID]["type"]
	put pNumber into mEditData[tComponentID]["number"]
	put true into mEditData[tComponentID]["mouseup"]
	end handler

public handler setActionRect(in pComponent as String, in pNumber as Number, \
		in pRect as Rectangle, in pTooltip as String, \
		in pAction as ActionCallback, in pMouseUp as Boolean)
	variable tComponentID as String
	put pComponent && pNumber formatted as string into tComponentID

	put the empty array into mEditData[tComponentID]

	put pRect into mEditData[tComponentID]["rect"]
	put pTooltip into mEditData[tComponentID]["tooltip"]
	put pComponent into mEditData[tComponentID]["type"]
	put pNumber into mEditData[tComponentID]["number"]
	put pAction into mEditData[tComponentID]["action"]
	put pMouseUp into mEditData[tComponentID]["mouseup"]
end handler

public handler drawEditableRects(in pCanvas as Canvas)
	variable tElement as Array
	repeat for each element tElement in mEditData
		set the paint of pCanvas to solid paint with color [0,0,0]
		stroke rectangle path of tElement["rect"] on pCanvas
	end repeat
end handler

private handler widgetClicked(in pClickPosition as Point, in pMouseUp as Boolean)
	if pMouseUp then
		dragDrop()
	end if

	variable tElement as Array
	repeat for each element tElement in mEditData
		if tElement["mouseup"] is pMouseUp and pClickPosition is within tElement["rect"] then
			if "popup" is among the keys of tElement then
				doPopup(pClickPosition, tElement)
			else if "action" is among the keys of tElement then
				doAction(tElement)
			else
				addEditableField(tElement)
			end if
		end if
	end repeat
end handler

private handler doPopup(in pClickPos as Point, in pArray as Array)
	variable tResult

	-- Popup the icon picker with the currently selected icon as the initial selection
	variable tProperties as Array
	put the empty array into tProperties
	if pArray["type"] is "selectedIcon" and mNavData[pArray["number"]]["hilited_icon_name"] is not "" then
		put mNavData[pArray["number"]]["hilited_icon_name"] into tProperties["selectedIcon"]
	else
		put mNavData[pArray["number"]]["icon_name"] into tProperties["selectedIcon"]
	end if

	popup widget pArray["popup"] at pClickPos with properties tProperties
	put the result into tResult

	variable tCallback as PopupCallback
	put pArray["callback"] into tCallback
	tCallback(tResult, pArray["type"], pArray["number"])
end handler

private handler doAction(in pArray as Array)
	variable tCallback as ActionCallback
	put pArray["action"] into tCallback
	tCallback(pArray["number"])
end handler

private handler formatRectAsString(in pRect as Rectangle)
	variable tResult as String
	put (the left of pRect) formatted as string into tResult
	put "," & (the top of pRect) formatted as string after tResult
	put "," & (the right of pRect) formatted as string after tResult
	put "," & (the bottom of pRect) formatted as string after tResult
	return tResult
end handler

private handler addEditableField(in pElement as Array)
	-- Work around the fact that LCB currently doesn't have editable text fields
	post "editField" with [formatRectAsString(pElement["rect"]), pElement["number"]]
end handler

end widget
