/*
Copyright (C) 2015 Runtime Revolution Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

/*
Description: This widget is a segmented control.
A segmented control is a horizontal control that is made up of multiple segments, where each segment functions as a discrete button.
*/

-- declaring extension as widget, followed by identifier
widget com.livecode.extensions.livecode.segmented
--

-- adding metadata to ensure the extension displays correctly in livecode
metadata title is "Segmented"
metadata author is "Georgia Hutchings"
metadata version is "1.0.0"
--

-- dependency declarations
use com.livecode.canvas
use com.livecode.widget
use com.livecode.engine
--

-- property declarations
property theme				get mTheme				set setTheme
property segmentStyle 		get mStyle				set setStyle			-- string (enum) : segment or bar
property multiSelect		get mMultiSelect		set setMultiSelect		

--property segementNames		get getSegmentNames		set setSegmentNames		-- list of optional strings
property segmentNames		get mSegmentNames		set setSegmentNames

property segmentLabels		get getSegmentLabels	set setSegmentLabels	-- list of optional strings
property segmentIcons		get getSegmentIcons		set setSegmentIcons		-- list of optional strings
property selectedIcons		get getSelectedIcons	set setSelectedIcons	-- list of optional strings

property segmentDisplay		get mSegmentDisplay		set setSegmentDisplay	-- string (enum) : text or icon
property segmentMinWidth	get getSegmentMinWidth	set setSegmentMinWidth	-- list of optional number
property selectedSegment	get getSelectedSegment	set setSelectedSegment	
--

-- private instance variables
--properties
private variable mTheme 			as string
private variable mStyle				as string
private variable mMultiSelect		as boolean

private variable mSegmentNames		as list
private variable mSegmentLabels		as list
private variable mSegmentIcons		as list
private variable mSelectedIcons		as list

private variable mSegmentDisplay	as string
private variable mSegmentMinWidth	as list
private variable mSelectedSegments	as list

--variables
private variable mGeometryIsChanged	as boolean
private variable mNumSegments		as integer
private variable mLeft				as real

private variable mPerimeter			as Rectangle
private variable mLines				as list			-- list of line paths
--

-- constants
constant kIconSize is 16
constant kTextSize is 13
--

----------
-- this handler is called when the widget is saved
public handler OnSave(out rProperties as array)
	put the empty array into rProperties
	
	put mTheme				into rProperties["theme"]
	put mStyle				into rProperties["style"]
	put mMultiSelect		into rProperties["multiSelect"]
	put mSegmentNames		into rProperties["segmentNames"]
	put mSegmentLabels		into rProperties["segmentLabels"]
	put mSegmentIcons		into rProperties["segmentIcons"]
	put mSelectedIcons		into rProperties["selectedIcons"]
	put mSegmentDisplay		into rProperties["segmentDisplay"]
	put mSegmentMinWidth	into rProperties["segmentMinWidth"]	
	put mSelectedSegments	into rProperties["selectedSegment"]
	
	return rProperties
end handler
----------

----------
-- this handler is called when the widget is created
public handler OnLoad(in pProperties as array)
	
	put pProperties["theme"]			into mTheme
	put pProperties["style"]			into mStyle
	put pProperties["multiSelect"]		into mMultiSelect
	put pProperties["segmentNames"]		into mSegmentNames
	put pProperties["segmentLabels"]	into mSegmentLabels
	put pProperties["segmentIcons"]		into mSegmentIcons
	put pProperties["selectedIcons"]	into mSelectedIcons
	put pProperties["segmentDisplay"]	into mSegmentDisplay
	put pProperties["segmentMinWidth"]	into mSegmentMinWidth
	put pProperties["selectedSegment"]	into mSelectedSegments
	
end handler
----------

----------
-- this handler is called when the widget is created
public handler OnCreate()
	
	-- properties
	put "ios-8" into mTheme
	put "segment" into mStyle
	put true into mMultiSelect
	
	put ["left","centre","right"] into mSegmentNames
	put ["Left","Centre","Right"] into mSegmentLabels
	put ["0xf036","0xf037","0xf038"] into mSegmentIcons
	put ["0xf036","0xf037","0xf038"] into mSelectedIcons
	
	put "icon" into mSegmentDisplay
	put [30,30,30] into mSegmentMinWidth
	put [1] into mSelectedSegments
	--
	
	-- variables
	put true into mGeometryIsChanged
	put (the number of elements in mSegmentNames) into mNumSegments
	put 0 into mLeft
	put rectangle [0,0,0,0] into mPerimeter
	put the empty list into mLines
	--
	
end handler
----------

----------
-- this handler is called whenever LiveCode needs to redraw the widget
public handler OnPaint()
	
	drawSegments()
	
	if mGeometryIsChanged then
		-- update mPerimeter and mLines variables if the geometry has changed
		updatePerimeter()
		updateLines()
	end if
	
	-- draw the lines to separate the segments
	set the antialias of this canvas to false
	set the stroke width of this canvas to 1
	set the paint of this canvas to fetchPaint("lines")
	
	variable tLine
	repeat for each element tLine in mLines
		stroke tLine on this canvas
	end repeat
	
	set the antialias of this canvas to true
	--
	
	-- draw the perimeter of the control
	set the paint of this canvas to fetchPaint("lines")
	set the stroke width of this canvas to 1
	stroke rectangle path of mPerimeter on this canvas
	--
	
	put false into mGeometryIsChanged
end handler
----------

----------
-- this handler is called whenever the geometry is changed
public handler OnGeometryChanged()
	put true into mGeometryIsChanged
end handler
----------

----------
-- this handler is called when the mouse is clicked
public handler OnClick(in pXLoc as integer, in pYLoc as integer, in pMouseButton as integer, in pClicks as integer)
	
	variable tX as integer
	variable tLabel as string
	variable tSegment
	variable tCount as integer
	 
	if mMultiSelect is false then
		-- if cannot multiselect, then need to select the clicked-on segment and deselect the currently selected segment
		-- if the clicked-on segment is already selected, then do nothing
	
		if the click position is not within fetchBounds(element 1 of mSelectedSegments) then
			repeat with tX from 1 up to mNumSegments
			
				if the click position is within fetchBounds(tX) then
					
					put the empty list into mSelectedSegments
					push tX onto back of mSelectedSegments
					
					put element tX of mSegmentNames into tLabel
					dispatch command "segmentSelected" to my script object with [tLabel]
				end if
				
			end repeat	
		end if
		
	else
		-- if can multiselect, then select the clicked-on segment if it is unselected or unselect if its selected
		-- cannot deselect a segment if it is the only selected segment
		
		repeat with tX from 1 up to mNumSegments
			if the click position is within fetchBounds(tX) then
		
				variable tIsIn
				put tX is in mSelectedSegments into tIsIn
		
				if tIsIn then
					if (the number of elements in mSelectedSegments) > 1 then
				
						put 1 into tCount
						variable tElement
						repeat for each element tElement in mSelectedSegments
							if tElement = tX then
								exit repeat
							end if
							add 1 to tCount
						end repeat
					
						delete element tCount of mSelectedSegments
						put element tX of mSegmentNames into tLabel
						dispatch command "segmentUnselected" to my script object with [tLabel]
						
					end if
				else
					put element tX of mSegmentNames into tLabel
					dispatch command "segmentSelected" to my script object with [tLabel]
					push tX onto back of mSelectedSegments
						
				end if
			end if
		end repeat
	end if
	
	redraw all
end handler
----------

----------
-- this handler draws the segments
private handler drawSegments() as undefined
	
	variable tX as integer
	variable tLabel as string
	variable tWidth as real
	variable tIsIn as boolean
	
	put 0 into mLeft
	set the font of this canvas to fetchFont()
	
	repeat with tX from 1 up to mNumSegments
		put fetchWidth(tX) into tWidth
		put tX is in mSelectedSegments into tIsIn
		
		if tIsIn then
	
			-- fill in the background of the selected segment(s)
			set the paint of this canvas to fetchPaint("lines")
			fill rectangle path of rectangle [mLeft, 0, mLeft+tWidth, my height] on this canvas
			--
			
			-- draw the label(s) in the selected segment(s)
			if mSegmentDisplay is "icon" then
				variable tSelectedIcon as string
				put element tX of mSelectedIcons into tSelectedIcon
				replace " " with "" in tSelectedIcon
				execute script ("return numtocodepoint(" & tSelectedIcon & ")")
				put the result into tLabel
			else
				put (element tX of mSegmentLabels) into tLabel
			end if
			
			set the paint of this canvas to fetchPaint("selected label")
			fill text tLabel at center of fetchLabelRect(tWidth) on this canvas
			--
		else
			
			-- draw the label(s) in the non-selected segment(s)
			if mSegmentDisplay is "icon" then
				variable tIcon as string
				put element tX of mSegmentIcons into tIcon
				replace " " with "" in tIcon
				execute script ("return numtocodepoint(" & tIcon & ")")
				put the result into tLabel
			else
				put (element tX of mSegmentLabels) into tLabel
			end if
			
			set the paint of this canvas to fetchPaint("label")	
			fill text tLabel at center of fetchLabelRect(tWidth) on this canvas
			--
			
		end if
		add tWidth to mLeft
	end repeat
	
end handler
----------

----------
-- this handler updates the mLines variable, a list of line paths that separate the segments
private handler updateLines() as undefined

	variable tX as integer
	variable tWidth as real
	variable tLeft as real
	
	put 0 into tLeft
	
	repeat with tX from 1 up to mNumSegments
	
		put fetchWidth(tX) into tWidth
		add tWidth to tLeft
		if tX < mNumSegments then
			push line path from point [tLeft, 0] to point [tLeft, my height] onto back of mLines
		end if
		
	end repeat
end handler
----------

----------
-- this handler updates the mPerimeter variable, a rectangle that is the perimeter of the control
private handler updatePerimeter() as undefined
	variable tRight as number
	variable tX as integer
	
	put 0 into tRight
	repeat with tX from 1 up to mNumSegments
	 	add fetchWidth(tX) to tRight
	end repeat
	
	put rectangle [0.5, 0.5, (the trunc of tRight) + 0.5, (the trunc of my height) - 0.5] into mPerimeter
end handler
----------

----------
-- this handler returns a path
private handler fetchPath(in pObject as string, in pInt as integer) as Path
	
	if pObject is "border" then
		return rounded rectangle path of rectangle [0.5, 0.5, (the trunc of my width)-0.5, (the trunc of my height)-0.5] with radius 2
	end if
	
end handler
----------

----------
-- this handler returns a paint
private handler fetchPaint(in pObject as string) as Paint
	
	if pObject is "lines" then
		return solid paint with color [51/255, 153/255, 1]
		
	else if pObject is "label" then
		return solid paint with color [51/255, 153/255, 1]
		
	else if pObject is "selected label" then
		return solid paint with color [1,1,1]
	
	end if

end handler
----------

----------
-- this handler returns a font
private handler fetchFont() as Font
	
	if mSegmentDisplay is "icon" then
		return font "fontawesome" at size 16 --kIconSize
		
	else
		if mTheme is "ios-8" then
			return font "Helvetica Neue" at size 13 --kTextSize
		end if
		
	end if
end handler
----------

----------
-- this handler returns a label rectangle
private handler fetchLabelRect(in pWidth as real) as Rectangle
	return rectangle [mLeft, 0, mLeft + pWidth, my height]
	
end handler
----------

----------
-- this handler returns the width of a segment
private handler fetchWidth(in pSegment as integer) as real
	
	variable tWidth as real
	
	if pSegment is 0 then
		return 0
	else
	
		if mSegmentDisplay is "icon" then
			put kIconSize into tWidth
		else
			put (the number of chars in element pSegment of mSegmentLabels)*(kTextSize/3)*2 into tWidth
		end if
		
		if tWidth < (element pSegment of mSegmentMinWidth) then
			put (element pSegment of mSegmentMinWidth) into tWidth
		end if
	
		return tWidth
	end if
	
end handler
----------
-- this handler returns the bounding box of a segment
private handler fetchBounds(in pSegment as integer) as Rectangle
	
	variable tLeft as real
	put 0 into tLeft
	
	variable tX as integer
	repeat with tX from 1 up to pSegment-1
	 	add fetchWidth(tX) to tLeft
	end repeat
		
	variable tWidth
	put fetchWidth(pSegment) into tWidth
	
	return rectangle [tLeft, 0, tLeft + tWidth, my height]
end handler
----------

/*
----------
-- this handler formats the segmentNames property for output in the property inspector
private handler getSegmentNames() as string

	variable tSegmentNames as string
	combine mSegmentNames with "," into tSegmentNames
	return tSegmentNames
	
end handler
----------
*/

----------
-- this handler formats the segmentLabels property for output in the property inspector
private handler getSegmentLabels() as string
	
	variable tSegmentLabels as string
	combine mSegmentLabels with "," into tSegmentLabels
	return tSegmentLabels

end handler
----------

----------
-- this handler formats the segmentIcons property for output in the property inspector
private handler getSegmentIcons() as string
	
	variable tSegmentIcons as string
	combine mSegmentIcons with "," into tSegmentIcons
	return tSegmentIcons
	
end handler
----------

----------
-- this handler formats the selectedIcons property for output in the property inspector
private handler getSelectedIcons() as string

	variable tSelectedIcons as string
	combine mSelectedIcons with "," into tSelectedIcons
	return tSelectedIcons
	
end handler
----------

----------
-- this handler formats the selectedSegments property for output in the property inspector
private handler getSelectedSegment() as string -- should be list of optional integers ??
	
	variable tSelectedSegment as string
	combine mSelectedSegments with "," into tSelectedSegment
	return tSelectedSegment
	
end handler
----------

----------
-- this handler formats the segmentMinWidths property for output in the property inspector
private handler getSegmentMinWidth() as string -- should be list of optional integers ??

	variable tSegmentMinWidth as string
	combine mSegmentMinWidth with "," into tSegmentMinWidth
	return tSegmentMinWidth
	
end handler
----------

----------
-- this handler sets the theme
/*
Summary: Sets the theme of the control.

Parameters:
pTheme: The name of the theme.

Description:
Sets the theme property of the control (currently, only "ios-8")
*/
private handler setTheme(in pTheme as string) as undefined
	put pTheme into mTheme
	put true into mGeometryIsChanged
	redraw all
end handler
----------

----------
-- this handler sets the style
/*
Summary: Sets the style of the control.

Parameters:
pStyle: The style of the control.

Description:
Sets the style property of the control (segmented control or bar button).
*/
private handler setStyle(in pStyle as string) as undefined
	put pStyle into mStyle
	put true into mGeometryIsChanged
	redraw all
end handler
----------

----------
-- this handler sets whether the control can have multiple segments selected
/*
Summary: Sets whether the control can have multiple segments selected

Parameters:
pCanMultiSelect:

Description:
Sets the multiSelect property of the control.
*/
private handler setMultiSelect(in pCanMultiSelect as boolean) as undefined
	put pCanMultiSelect into mMultiSelect
end handler
----------

----------
-- this handler sets the names of the segments
/*
Summary: Sets the names of the segments.

Parameters:
pNames: A comma-delimited list of names for the segments.

Descriptions:
Sets the segmentNames property of the control; sets the names of each segment in the control.
*/
/*private handler setSegmentNames(in pNames as string) as undefined
	split pNames by "," into mSegmentNames
	put 1 into mSelectedSegments
	put true into mGeometryIsChanged
	redraw all
end handler*/
private handler setSegmentNames(in pNameList as list) as undefined
	put pNameList into mSegmentNames
	put true into mGeometryIsChanged
	redraw all
end handler
----------	

----------
-- this handler sets the labels of the segments
/*
Summary: Sets the labels of the segments.

Parameters:
pLabels: A comma-delimited list of labels for the segments.

Descriptions:
Sets the segmentLabels property of the control; sets the labels of each segment in the control.
*/
private handler setSegmentLabels(in pLabels as string) as undefined
	split pLabels by "," into mSegmentLabels
	put true into mGeometryIsChanged
	redraw all
end handler
----------

----------
-- this handler sets the icons of the segments
/*
Summary: Sets the icons of the segments.

Parameters:
pIcons: A comma-delimited list of fontawesome icons for the segments

Description:
Sets the segmentIcons property of the control; sets the icons of each segment in the control.
*/
private handler setSegmentIcons(in pIcons as string) as undefined
	split pIcons by "," into mSegmentLabels
	put true into mGeometryIsChanged
	redraw all
end handler
----------

----------
-- this handler sets the selected icons of the segments
/*
Summary: Sets the selected icons of the segments.

Parameters:
pSelectedIcons: A comma-delimited list of fontawesome icons.

Description:
Sets the selectedIcons property of the control; sets the selected icons of each segment in the control.
*/
private handler setSelectedIcons(in pSelectedIcons as string) as undefined
	split pSelectedIcons by "," into mSelectedIcons
	put true into mGeometryIsChanged
	redraw all
end handler
----------

----------
/*
Summary: Sets the segment display style.

Parameters:
pSegmentDisplay: The style of the segment display.

Description:
Sets the segmentDisplay property of the control to either icon or label.
*/
private handler setSegmentDisplay(in pSegmentDisplay as string) as undefined
	put pSegmentDisplay into mSegmentDisplay
	put true into mGeometryIsChanged
	redraw all
end handler
----------

----------
/*
Summary: Sets the minimum widths of the segments.

Parameters:
pMinWidths: A comma-delimited list of numbers.

Description:
Sets the segmentMinWidth property of the control; sets the minimum width of each segment in the control.
*/
private handler setSegmentMinWidth(pMinWidths) as undefined -- as string? list? number?
	put pMinWidths into mSegmentMinWidth
	put true into mGeometryIsChanged
	redraw all
end handler
----------

----------
/*
Summary: Sets the selected segment.

Parameters:
pSelectedSegment: The number of the selected segment.

Description:
Sets the selectedSegment property of the control; sets the selected segment of the control
*/
private handler setSelectedSegment(in pSelectedSegment as optional integer) as undefined
	put pSelectedSegment into mSelectedSegments
	redraw all
end handler 
----------

end widget