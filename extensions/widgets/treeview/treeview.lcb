/*
Copyright (C) 2015 - 2016 LiveCode Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

/**
A widget to display array data in a tree view

Name: hiliteChanged
Type: message
Syntax: hiliteChanged

Summary: Sent when an element is hilited

Description:
The <hiliteChanged> message is sent to the widget's script object when a row of the 
widget's display is clicked on, causing that row to be highlighted. Use the <hilitedElement>
property to fetch the row's associated array keys.

References: hilitedElement (property)

A widget to display array data in a tree view

Name: dataChanged
Type: message
Syntax: dataChanged

Summary: Sent when the arrayData of the widget changes

Description:
The <dataChanged> message is sent to the widget's script object when the underlying
<arrayData> of the tree view changes.

References: arrayData (property)

Name: actionInspect
Type: message
Syntax: actionInspect <pPath>

Summary: Sent when an the inspect icon is clicked in read only mode

Parameters:
pPath: The path to the clicked element

Description:
The actionInspect message is sent to the widget's script object when the inspect icon is clicked on.
The inspect icon appears when the value string of a particular array element contains a newline character,
or if it is too large to fit in the space provided. The <pPath> parameter contains the path to the 
element whose icon was clicked.

Name: actionDoubleClick
Type: message
Syntax: actionDoubleClick <pPath>

Summary: Sent when a leaf node of the tree view is double-clicked.

Parameters:
pPath: The path to the clicked element

Description:
The actionDoubleClick message is sent to the widget's script object when a row of the widget
is double-clicked. The <pPath> parameter contains the path to the element whose row was clicked.

Name: formattedHeightChanged
Type: message
Syntax: formattedHeightChanged

Summary: Sent when the formatted height of the displayed data changes.

Description:
The formattedHeightChanged message is sent to the widget's script object when
the formatted height of the displayed data changes.  This is useful when
using a mobileScroller to control the widget view.
**/

widget com.livecode.widget.treeview

use com.livecode.canvas
use com.livecode.widget
use com.livecode.engine
use com.livecode.library.widgetutils
use com.livecode.foreign

metadata author is "LiveCode"
metadata version is "2.4.0"
metadata title is "Tree View"
metadata svgicon is "M152.4,249.7c-6.4,0-11.8,4.3-13.5,10.1h-10v-26.7h10c1.7,5.8,7.1,10.1,13.5,10.1c7.8,0,14.1-6.3,14.1-14.1s-6.3-14.1-14.1-14.1c-6.4,0-11.8,4.3-13.5,10.1h-10v-16.1c8.4-1.8,14.8-9.3,14.8-18.3c0-10.4-8.4-18.8-18.8-18.8s-18.8,8.4-18.8,18.8c0,9,6.3,16.5,14.7,18.3v58.8h18c1.7,5.8,7.1,10.1,13.5,10.1c7.8,0,14.1-6.3,14.1-14.1S160.2,249.7,152.4,249.7z M128.7,202h-7.5v-7.5h-7.5V187h7.5v-7.5h7.5v7.5h7.5v7.5h-7.5V202z"
metadata _ide is "true"

-- property declarations
/**
Syntax: set the arrayData of <widget> to <pArray>
Syntax: get the arrayData of <widget>
Summary: The array being displayed by the widget

Parameters:
pArray (array): The array data.

Description:
The arrayData is the data currently being displayed by the tree view widget.
**/

property arrayData 					get getArrayData 				set setArrayData
metadata arrayData.label is "Array data"

/**
Syntax: set the foldState of <widget> to <pFoldState>
Syntax: get the foldState of <widget>
Summary: The fold state of the array being displayed by the widget

Parameters:
pFoldState (array): The fold state data.  See description for details.

Description:
The foldState is the fold state currently being displayed by the tree view widget.

The fold state array only contains elements of the data array where the
value is a subarray.  The value for each `folded` key must be a boolean.
Only the unfolded keys need to be specified.

```
	[key1]
		["folded"]
		["array"]
			[subkey1]
				["folded"]
	[key2]
		["folded"]
```

Setting the foldState to empty will fold all keys.
**/

property foldState 					get getFoldState 				set setFoldState
metadata foldState.user_visible is "false"

/**
Syntax: set the hilitedElement of <widget> to <pPath>
Syntax: get the hilitedElement of <widget>

Summary: Select the row corresponding to <pPath>

Parameters:
pPath: A comma delimited list of array keys.

Description:
<pPath> is a list of the keys which determine the row to be selected. For example, if tArray is the arrayData
of the widget, to select a row corresponding to tArray["key1"]["subkey2"]["subsubkey5"], simply execute

``` set the hilitedElement of widget "Array Viewer" to "key1,subkey2,subsubkey5" ```

Setting to an invalid path or to `empty` will unselect the currently selected row.
**/

property hilitedElement			get getSelectedElement			set setSelectedElement
metadata hilitedElement.label is "Hilited element"

/**
Syntax: set the hilitedElementFoldState of <widget> to <pFoldState>
Syntax: get the hilitedElementFoldState of <widget>

Summary: Get/set the fold state of the selected element

Parameters:
pFoldState (enum): The fold state of the selected element.
- "folded": Sub-array for the selected element is hidden.
- "unfolded": Sub-array for the selected element is visible.
- "leaf": Selected element is a leaf node.  This value may not be set.

Description:
<pFoldState> is the fold state of the selected element.  When setting
the fold state, attempts to set the value for a leaf node will have no
effect.  Setting the fold state when no element is selected has no effect.
**/

property hilitedElementFoldState			get getSelectedElementFoldState			set setSelectedElementFoldState
metadata hilitedElementFoldState.user_visible is "false"

/**
Syntax: set the hilitedElementIsFolded of <widget> to {true|false}
Syntax: get the hilitedElementIsFolded of <widget>

Summary: Determine if the selected element is folded

Description:
Value is true if the selected element is folded.  False is returned in
all other cases including when nothing is selected and when a leaf node is
selected.  When setting the fold state, attempts to set the value for a leaf 
node will have no effect.  Setting the fold state when no element is selected 
has no effect.
**/

property hilitedElementIsFolded			get getSelectedElementIsFolded			set setSelectedElementIsFolded
metadata hilitedElementIsFolded.user_visible is "false"

/**
Syntax: set the hiliteNewElement of <widget> to {true|false}
Syntax: get the hiliteNewElement of <widget>

Summary: Automatically select new elements when created interactively.

Description:
If the <readOnly> property is false and the <hiliteNewElement> property is true,
then when new array elements are added, they will be automatically selected.

References: readOnly (property)
**/

property hiliteNewElement		get mHiliteNewElement		set mHiliteNewElement
metadata hiliteNewElement.label is "Hilite new element"

/**
Syntax: set the scrollHilitedElementIntoView of <widget> to {true|false}
Syntax: get the scrollHilitedElementIntoView of <widget>

Summary: Automatically scroll selected row into view.

Description:
If the <scrollHilitedElementIntoView> property is true, then when the 
<hilitedElement> property changes the view will be scrolled such that the 
selected row is visible.

References: hilitedElement (property)
**/

property scrollHilitedElementIntoView		get mScrollHilitedElementIntoView		set mScrollHilitedElementIntoView
metadata scrollHilitedElementIntoView.label is "Scroll hilited element into view"

/**
Syntax: set the autoFoldStateReset of <widget> to {true|false}
Syntax: get the autoFoldStateReset of <widget>

Summary: Automatically reset fold state when array data is set.

Description:
Use the <autoFoldStateReset> property to determine if the fold state is
reset (tree is completely folded) when the <arrayData> property is set.

References: arrayData (property)
**/

property autoFoldStateReset			get mAutoFoldStateReset				set mAutoFoldStateReset
metadata autoFoldStateReset.label is "Automatically reset fold state when array data is set"

/**
Name: foreColor

Type: property

Syntax: set the foreColor of <widget> to <pColor>
Syntax: get the foreColor of <widget>

Summary: The color used for the text of the tree view.

Parameters:
pColor: Any color name, or RGB value.

Description:
Use the <foreColor> property to get or set the color the tree view widget uses for its text.
**/

metadata foregroundColor.default is "50,50,50"
metadata foregroundColor.label is "Text color"

/**
Name: backColor

Type: property

Syntax: set the backColor of <widget> to <pColor>
Syntax: get the backColor of <widget>

Summary: The color used for the background of the rows of the tree view.

Parameters:
pColor: Any color name, or RGB value.

Description:
Use the <backColor> property to get or set the color the tree view widget uses for the
background of its rows.
**/
metadata backgroundColor.default is "244,244,244"
metadata backgroundColor.label is "Row background color"

/**
Syntax: set the hiliteColor of <widget> to <pColor>
Syntax: get the hiliteColor of <widget>

Summary: The color used to highlight a selected row.

Parameters:
pColor: Any color name, or RGB value.

Description:
Use the <hiliteColor> property to get or set the color the tree view widget uses to highlight 
the selected row.
**/

metadata hiliteColor.default is "10,95,244"
metadata hiliteColor.label is "Selected row color"

/**
Name: borderColor

Type: property

Syntax: set the borderColor of <widget> to <pColor>
Syntax: get the borderColor of <widget>

Summary: The color used for the border and the separator of the tree view.

Parameters:
pColor: Any color name, or RGB value.

Description:
Use the <borderColor> property to get or set the color the tree view widget uses for its
border, and the separator (if the <showSeparator> property is true).

References: showSeparator (property)
**/
metadata borderColor.default is "109,109,109"
metadata borderColor.label is "Border color"

/**
Syntax: set the sortOrder of <widget> to <pOrder>
Syntax: get the sortOrder of <widget>

Summary: Manipulates the order in which elements of the tree view are displayed, with respect to the current <sortType>.

Parameters:
pOrder (enum): The order in which to display elements of the tree view.
- "ascending": Display from first to last in the order. This is the default
- "descending": Display from last to first in the order.

Description:
Use the <sortOrder> property to display the elements of the tree view in ascending or descending order of the
keys of its <arrayData>, given the current <sortType>.

References: arrayData (property), sortType (property)
**/

property sortOrder                 get getSortOrder                 set setSortOrder

metadata sortOrder.editor is "com.livecode.pi.enum"
metadata sortOrder.options is "ascending,descending"
metadata sortOrder.label is "Sort order"

/**
Syntax: set the sortType of <widget> to <pType>
Syntax: get the sortType of <widget>

Summary: Manipulates the type of ordering in which elements of the tree view are displayed.

Parameters:
pType (enum): The type of ordering to use in displaying elements of the tree view.
- "text": Display in alphabetical order of the keys
- "numeric": Display in numeric order of the keys. This is the default

Description:
Use the <sortType> property to use text or numeric comparison when ordering the keys of the <arrayData>
of the tree view widget.

References: sortOrder (property)
**/

property sortType                 get getSortType                 set setSortType

metadata sortType.editor is "com.livecode.pi.enum"
metadata sortType.options is "text,numeric"
metadata sortType.label is "Sort type"

/**
Name: pathDelimiter

Type: property

Syntax: set the pathDelimiter of <widget> to <pType>
Syntax: get the pathDelimiter of <widget>

Summary: Manipulates the separator between the elements of the array viewer

Description:
Use the <pathDelimiter> property as the separator between the elements describing
a path in the tree view widget.
**/

property pathDelimiter		get mPathDelimiter		set mPathDelimiter
metadata pathDelimiter.label is "Path delimiter"
metadata pathDelimiter.default is ","

/**
Syntax: set the alternateRowBackgrounds of <widget> to {true|false}
Syntax: get the alternateRowBackgrounds of <widget>

Summary: Whether the alternate rows of the widget have different backgrounds or not.

Description:
Use the alternateRowBackgrounds property if you want to more clearly distinguish the rows displayed by the widget.
**/

property alternateRowBackgrounds 	get mAlternateRowBackgrounds 	set setRowBackgrounds
metadata alternateRowBackgrounds.label is "Alternate row backgrounds"

/**
Syntax: set the showBorder of <widget> to {true|false}
Syntax: get the showBorder of <widget>

Summary: Whether the widget has a border or not.

Description:
Use the <showBorder> property to show or hide the bounds of the widget 
object.
**/

property showBorder			get mFrameBorder				set setFrameBorder
metadata showBorder.label is "Show border"

/**
Syntax: set the showHover of <widget> to {true|false}
Syntax: get the showHover of <widget>

Summary: Whether the widget has a hover row displayed or not.

Description:
Use the <showHover> property to show or hide the hover row of the widget 
object.
**/

property showHover			get mShowHover				set setShowHover
metadata showHover.label is "Show hover row"

/**
Syntax: set the readOnly of <widget> to {true|false}
Syntax: get the readOnly of <widget>

Summary: Whether the options to modify elements of the underlying array are present or not.

Description:
The <readOnly> property controls whether the widget presents the option to add elements to arrays or not.
If false, the first row of the widget is always "Add new element", and when rows are hovered over, icons
appear at the right to enable the removal of that element, or the addition of a new subelement.

**/

property readOnly					get mReadOnly					set setReadOnly
metadata readOnly.label is "Read only"

/**
Syntax: set the arrayStyle of <widget> to {true|false}
Syntax: get the arrayStyle of <widget>

Summary: Whether the tree view should display its contents in array style or as a standard tree view.

Description:
The <arrayStyle> property controls whether the keys of the <arrayData> of the widget are displayed with
square brackets around them or not.

References: arrayData (property)
**/

property arrayStyle                 get mArrayStyle                 set setArrayStyle
metadata arrayStyle.label is "Array style"

/**
Syntax: set the charsToTrimFromKey of <widget> to <pChars>
Syntax: get the charsToTrimFromKey of <widget>

Summary: The number of leading characters to trim from the key for display.

Parameters:
pChars: Number of leading characters to trim from the key.

Description:
The <charsToTrimFromKey> property controls the number of leading characters that 
are removed from the keys of the <arrayData> of the widget.  This allows
a custom sort where the sort portion of the key is not displayed.

With <charsToTrimFromKey> set to 2, the following array:
```
	[1 CCC]
	[2 BBB]
	[3 AAA]
```

Would display in the widget as:
```
[CCC]
[BBB]
[AAA]
```

References: arrayData (property)
**/

property charsToTrimFromKey                 get mCharsToTrimFromKey                 set setCharsToTrimFromKey
metadata charsToTrimFromKey.label is "Key chars to trim"

/**
Syntax: get the formattedHeight of <widget>

Summary: Height of the data displayed by the widget

Description:
Use the <formattedHeight> property to get the height of the data displayed
by the widget in the current fold state.
**/
property formattedHeight	get mDataHeight
metadata formattedHeight.user_visible is "false"

/**
Syntax: set the scroll of <widget> to <pScroll>
Syntax: get the scroll of <widget>
Syntax: get the vScroll of <widget>

Summary: Vertical scroll position of the widget

Parameters:
pScroll: Vertical scroll position of the widget

Description:
Use the <scroll> property to get or set the scroll position of
the widget.
**/
property scroll							get mViewTopPosition		set setViewTopPosition
metadata scroll.user_visible is "false"

/**
Syntax: set the textHeight of <widget> to <pTextHeight>
Syntax: get the textHeight of <widget>

Summary: Custom text height for the widget

Parameters:
pTextHeight: Custom text height for the widget

Description:
Use the <textHeight> property to set a custom text (row) height for
the widget.  The default value is 0 which will use the calculated height
based on the currently selected font and size.
**/
property textHeight						get mTextHeight			set mTextHeight
metadata textHeight.label is "Text Height"
metadata textHeight.default is "0"

/**
Syntax: set the iconHeight of <widget> to <pIconHeight>
Syntax: get the iconHeight of <widget>

Summary: Custom icon height for the widget

Parameters:
pIconHeight: Custom icon height for the widget

Description:
Use the <iconHeight> property to set a custom icon size for
the widget.  The default value is 10.
**/
property iconHeight						get mIconHeight			set setIconHeight
metadata iconHeight.label is "Icon Height"
metadata iconHeight.default is "10"

/**
Name: vScrollbar
Type: property

Syntax:
set the vScrollbar of <widget> to <pEnabled>
get the vScrollbar of <widget>

Summary: Controls the visibility of the browser's vertical scrollbar.

Value (boolean): 
`true` if the vertical scrollbar should be enabled and displayed; 
`false` otherwise.

Description:
Use the <vScrollbar> property to control the visibility of the widget's
vertical scrollbar
*/
property vScrollbar get mVScrollbar set setVScrollbar
metadata vScrollbar.editor is "com.livecode.pi.boolean"
metadata vScrollbar.default is "true"
metadata vScrollbar.label is "Vertical scrollbar"

/**
Syntax: set the showValues of <widget> to {true|false}
Syntax: get the showValues of <widget>

Summary: Whether the values are displayed or not

Description:
Use the <showValues> property to display or hide the values of the <arrayData>  
of the tree view widget.  This setting will be useful when using the
widget as a menu for navigation purposes.

Hiding values effectively hides the separator as well.

Related: showSeparator (property)
**/
property showValues		get mShowValues		set setShowValues
metadata showValues.label is "Show values"

/**
Syntax: set the showSeparator of <widget> to {true|false}
Syntax: get the showSeparator of <widget>

Summary: Whether the separator bar between keys and values is showing or not

Description:
Use the <showSeparator> property to display the keys and values of the <arrayData>  
of the tree view widget in columns separated by a movable divide.

Related: separatorRatio (property)
**/
property showSeparator		get mShowSeparator		set setShowSeparator
metadata showSeparator.label is "Show separator"

/**
Syntax: set the separatorRatio of <widget> to {true|false}
Syntax: get the separatorRatio of <widget>

Summary: Manipulates the size of the arrayData view columns.

Description:
Use the <separatorRatio> property to display the keys and values of the <arrayData>  
of the tree view widget in columns separated by a movable divide.

The <separatorRatio> is the size of the first column as a ratio of the total view area.

Related: showSeparator (property)
**/
property separatorRatio		get mSeparatorRatio		set setSeparatorRatio
metadata separatorRatio.editor is "com.livecode.pi.number"
metadata separatorRatio.step is "0.05"
metadata separatorRatio.min is "0"
metadata separatorRatio.max is "1"
metadata separatorRatio.label is "Separator ratio"

metadata themeClass.default is "list"
metadata themeClass.user_visible is "false"

// The unmodified array data
private variable mData as Array
// A flat list representing the array items to be displayed
private variable mDataList as optional List
// The number of lines to be displayed
private variable mDataCount as Integer
// The total height of the displayed data
private variable mDataHeight as Real
// The height of each row
private variable mRowHeight as Real
private variable mTextHeight as Real
private variable mFontSize as Integer
private variable mFontName as String

// The height of the view area
private variable mViewHeight as Real
// The width of the view area
private variable mViewWidth as Real

// The first part of the data being displayed
private variable mViewTopPosition as Real
// The index in the display list corresponding the the top of the view
private variable mFirstDataItem as Integer

private variable mRecalculate as Boolean
private variable mUpdateSeparator as Boolean
private variable mUpdateDataList as Boolean
private variable mRecalculateFit as Boolean
private variable mRedraw as Boolean
private variable mFoldChanged as Boolean

private variable mAlternateRowBackgrounds as Boolean
private variable mVScrollbar as Boolean

private variable mIndentPixels as Integer
private variable mHoverRow as Integer
private variable mHoverIcon as String
private variable mMouseDownRow as Integer
private variable mScrolledSinceMouseDown as Boolean

private variable mFrameBorder as Boolean
private variable mShowHover as Boolean

private variable mSelectedElement as optional List
private variable mFoldState as Array
private variable mAutoFoldStateReset as Boolean
private variable mLastKeyAdded as optional String
private variable mHiliteNewElement as Boolean
private variable mScrollHilitedElementIntoView as Boolean

private variable mFoldedArrowPath as Path
private variable mUnfoldedArrowPath as Path
private variable mDeleteItemPath as Path
private variable mAddItemPath as Path
private variable mInspectItemPath as Path

private variable mIconRect as Rectangle
private variable mIconWidth as Real
private variable mIconHeight as Integer
private variable mRightIconMargin as Real

private variable mReadOnly as Boolean
private variable mArrayStyle as Boolean

private variable mSortAscending as Boolean
private variable mSortNumeric as Boolean

private variable mPathDelimiter as String

private variable mCharsToTrimFromKey as Integer

private variable mShowValues as Boolean
private variable mShowSeparator as Boolean
private variable mSeparatorRatio as Number
private variable mSeparatorDragging as Boolean

private variable mOldTooltip as optional String

constant kRowBuffer is 1000

constant kRowTextPadding is 4
constant kItemPadding is 6
constant kSeparatorWidth is 4
constant kStrokeWidth is 1
constant kIconHeight is 10
--------------------------------------------------------------------------------
--
--		Message handlers
--
--------------------------------------------------------------------------------

public handler OnCreate() returns nothing
	put 21 into mRowHeight
	put kIconHeight into mIconHeight
	UpdateIconRects()
	
	put 0 into mTextHeight
	put true into mAlternateRowBackgrounds
	put the size of my font into mFontSize
	put the name of my font into mFontName
	
	put my height into mViewHeight
	put my width into mViewWidth	
	
	put 0 into mHoverRow
	put "" into mHoverIcon
	put 0 into mViewTopPosition
	put true into mFrameBorder
	put true into mShowHover
	put true into mVScrollbar
	initialiseScrollbar()	
	
	put false into mReadOnly
	put false into mArrayStyle

	put true into mSortNumeric
	put true into mSortAscending

	put "," into mPathDelimiter

	put true into mRecalculate
	put true into mUpdateDataList
	put true into mUpdateSeparator
	put true into mRecalculateFit
	put true into mRedraw
	put false into mFoldChanged
	
	put 0 into mCharsToTrimFromKey
	
	put true into mShowValues
	put false into mShowSeparator
	put 0.5 into mSeparatorRatio
	put false into mSeparatorDragging
	
	put the empty array into mFoldState
	put the empty array into mData
	put false into mAutoFoldStateReset
	put false into mHiliteNewElement
	put false into mScrollHilitedElementIntoView
end handler

public handler OnSave(out rProperties as Array)
	put the empty array into rProperties
	put mData into rProperties["array"]
	put mReadOnly into rProperties["read only"]
	put mArrayStyle into rProperties["array style"]
	put mSortAscending into rProperties["sort ascending"]
	put mSortNumeric into rProperties["sort numeric"]
	put mAutoFoldStateReset into rProperties["auto fold state reset"]
	put mHiliteNewElement into rProperties["hilite new element"]
	put mScrollHilitedElementIntoView into rProperties["scroll hilited element into view"]
	put mTextHeight into rProperties["text height"]
	put mIconHeight into rProperties["icon height"]
	put mFrameBorder into rProperties["show border"]
	put mShowHover into rProperties["show hover row"]
	put mVScrollbar into rProperties["vertical scrollbar"]
	put mAlternateRowBackgrounds into rProperties["alternate row backgrounds"]

	put mCharsToTrimFromKey into rProperties["chars to trim from key"]
	put mShowValues into rProperties["show values"]
	put mShowSeparator into rProperties["show separator"]
	put mSeparatorRatio into rProperties["separator ratio"]
	return rProperties
end handler

public handler OnLoad(in pProperties as Array)
	put pProperties["read only"] into mReadOnly

	if "array style" is among the keys of pProperties then
		put pProperties["array style"] into mArrayStyle
	end if

	if "sort ascending" is among the keys of pProperties then
		put pProperties["sort ascending"] into mSortAscending
	end if

	if "sort numeric" is among the keys of pProperties then
		put pProperties["sort numeric"] into mSortNumeric
	end if

	if "auto fold state reset" is among the keys of pProperties then
		put pProperties["auto fold state reset"] into mAutoFoldStateReset
	end if

	if "hilite new element" is among the keys of pProperties then
		put pProperties["hilite new element"] into mHiliteNewElement
	end if

	if "scroll hilited element into view" is among the keys of pProperties then
		put pProperties["scroll hilited element into view"] into mScrollHilitedElementIntoView
	end if

	if "text height" is among the keys of pProperties then
		put pProperties["text height"] into mTextHeight
	end if

	-- Prepare for being able to specify custom icons
	variable tRecalculateIcons as Boolean
	put false into tRecalculateIcons
	if "icon height" is among the keys of pProperties then
		put pProperties["icon height"] into mIconHeight
		put mIconHeight is not kIconHeight into tRecalculateIcons
	end if

	if "show border" is among the keys of pProperties then
		put pProperties["show border"] into mFrameBorder
	end if

	if "show hover row" is among the keys of pProperties then
		put pProperties["show hover row"] into mShowHover
	end if

	if "vertical scrollbar" is among the keys of pProperties then
		put pProperties["vertical scrollbar"] into mVScrollbar
	end if

	if "alternate row backgrounds" is among the keys of pProperties then
		put pProperties["alternate row backgrounds"] into mAlternateRowBackgrounds
	end if

	if "chars to trim from key" is among the keys of pProperties then
		put pProperties["chars to trim from key"] into mCharsToTrimFromKey
	end if

	if "show values" is among the keys of pProperties then
		put pProperties["show values"] into mShowValues
	end if

	if "show separator" is among the keys of pProperties then
		put pProperties["show separator"] into mShowSeparator
	end if

	if "separator ratio" is among the keys of pProperties then
		put pProperties["separator ratio"] into mSeparatorRatio
	end if

	if tRecalculateIcons then
		UpdateIconRects()
	end if
	setArrayData(pProperties["array"])
end handler

private handler elementIsProxyForMoreData(in pElement as Array) returns Boolean
	return "more_data" is among the keys of pElement
end handler

public handler OnPaint() returns nothing
	variable tFontSize as Integer
	put the size of my font into tFontSize
	if tFontSize is not mFontSize then
		put tFontSize into mFontSize
		put true into mRecalculate
		put true into mRecalculateFit
		put nothing into mEllipsisLength
	end if

	variable tFontName as String
	put the name of my font into tFontName
	if tFontName is not mFontName then
		put tFontName into mFontName
		put true into mRecalculate
		put true into mRecalculateFit
		put nothing into mEllipsisLength
	end if
	
	variable tRowHeight as Integer
	if mTextHeight > 0 then
		put mTextHeight into tRowHeight
	else
		put tFontSize + 2 * kRowTextPadding into tRowHeight
	end if
	if tRowHeight is not mRowHeight then
		put tRowHeight into mRowHeight
		put true into mRecalculate
		put true into mRecalculateFit
	end if
	
	set the font of this canvas to my font
	if mUpdateDataList then
		updateDataList()
	end if

	// If anything has changed requiring a recalculation, update parameters
	if mRecalculate then
		updateParameters()
	end if
	
	if mUpdateSeparator or mRecalculateFit then
		updateSeparator()
	end if

	variable tTop as Real
	put 0 into tTop
	
	variable tX as Integer
	put 1 into tX
	
	variable tTopOffset
	put mViewTopPosition mod mRowHeight into tTopOffset
	subtract tTopOffset from tTop
	
	// Iterate from the first data item drawing each row until
	// we can't display any more items
	repeat with tX from mFirstDataItem up to mDataCount
		if tX is 1 then
			paintFirstRow(tTop)
		else
			variable tElement as Array
			put element tX of mDataList into tElement
			if elementIsProxyForMoreData(tElement) then
				addToListBuffer(tX, tElement, mDataList)
				updateParameters()
				updateSeparator()
				put mDataList[tX] into tElement
			end if
			
			paintDataItem(tElement, tTop, tX)
		end if
		if tTop > mViewHeight then
			exit repeat
		end if
		add mRowHeight to tTop
	end repeat
	
	if mShowValues and mShowSeparator then
		paintSeparator()
	end if	

	// Paint the scrollbar
	if mVScrollbar then
		paintScrollbar(this canvas)
	end if
	
	// Draw the frame
	if mFrameBorder is true then
		variable tPath as Path
		put rectangle path of rectangle [0.5,0.5,mViewWidth-0.5,mViewHeight-0.5] into tPath
		paintBorder(tPath)
	end if
end handler

// Utility for painting the separator
private handler paintSeparator()
	set the stroke width of this canvas to kStrokeWidth
	set the paint of this canvas to my border paint

	variable tPath as Path
	
	variable tStart as Point
	put separatorStart() into tStart
	
	variable tEnd as Point
	put point [the x of tStart, my height] into tEnd
	
	put line path from tStart to tEnd into tPath
	stroke tPath on this canvas
end handler

// Utility for painting the first (Add new element) row
private handler paintFirstRow(in pTop as Real)
	// Apply any style to this data item
	variable tStyle as String
	put "" into tStyle

	variable tHover as Boolean
	put (mHoverRow is 1) and mShowHover into tHover
		
	variable tPath as Path	
	put rectangle path of rectangle [0,pTop,mViewWidth,pTop+mRowHeight] into tPath
	paintRow(tPath, tHover, false, false)
		
	variable tLeft as Real
	put kItemPadding into tLeft
	
	// Draw the plus icon
	put mAddItemPath into tPath
	translate tPath by [kItemPadding + mIconWidth / 2, pTop + mRowHeight / 2]
	paintIcon(tPath, false, false)
	
	// Draw text
	variable tTextRect as Rectangle
	put rectangle [mIconWidth + 2 * kItemPadding, pTop, mViewWidth - 3 * kItemPadding - 2 * mIconWidth, pTop + mRowHeight] into tTextRect
	paintText("Add new element", "left", tTextRect, false, false)
end handler

private handler keyRight() returns Real
	if mShowValues and mShowSeparator then
		return mSeparatorRatio * availableSeparatorSpace()
	else
		return mViewWidth - mRightIconMargin
	end if
end handler

private handler keyLeft(in pDataItem as Array) returns Real
	variable tLeft as Real
	put kItemPadding + (pDataItem["indent"] * mIndentPixels) into tLeft
	add mIconWidth + kItemPadding to tLeft
	return tLeft
end handler

private handler valueLeft(in pKeyLeft as Real) returns Real
	return pKeyLeft + 2 * kItemPadding
end handler

private handler valueRight() returns Real
	return mViewWidth - mRightIconMargin
end handler

// Utility for painting a row with top pTop
private handler paintDataItem(in pDataItem as Array, in pTop as Real, in pRow as Integer)
	// Apply any style to this data item
	variable tHover as Boolean
	put (pRow is mHoverRow) and mShowHover into tHover
	
	variable tAlternate as Boolean
	if mAlternateRowBackgrounds and pRow mod 2 is 0 then
		put true into tAlternate
	else
		put false into tAlternate
	end if
		
	variable tPath as Path	
	put rectangle path of rectangle [0,pTop,mViewWidth,pTop+mRowHeight] into tPath
	paintRow(tPath, tHover, pDataItem["selected"], tAlternate)
	
	variable tLeft as Real
	put kItemPadding + (pDataItem["indent"] * mIndentPixels) into tLeft
		
	// Draw the fold/unfold arrow if applicable
	if not pDataItem["leaf"] then
		if pDataItem["folded"] is true then
			put mFoldedArrowPath into tPath
		else
			put mUnfoldedArrowPath into tPath	
		end if
		save state of this canvas
		translate tPath by [tLeft + mIconWidth / 2, pTop + mRowHeight / 2]
		paintIcon(tPath, false, pDataItem["selected"])
		if mShowValues and mShowSeparator then
			clip to rectangle [tLeft, pTop, mSeparatorRatio * availableSeparatorSpace(), pTop + mRowHeight] on this canvas
		end if	
		fill tPath on this canvas
		restore state of this canvas
	end if
	
	add mIconWidth + kItemPadding to tLeft

	// Draw the key
	variable tDisplayRect as Rectangle
	put rectangle [tLeft, pTop, keyRight(), pTop + mRowHeight] into tDisplayRect
	if not mShowSeparator then
		variable tTextBounds as Rectangle
		measure pDataItem["display_key"] on this canvas
		put the result into tTextBounds
		set the width of tDisplayRect to the width of tTextBounds
		put tDisplayRect into pDataItem["keyRect"]
	end if
	put valueLeft(the right of tDisplayRect) into tLeft
	
	paintText(pDataItem["display_key"], "left", tDisplayRect, true, pDataItem["selected"])
	
	// Draw the value if it is a 'leaf' (i.e. if it does not contain a sub-array)
	if mShowValues and pDataItem["leaf"] then
		put rectangle [tLeft, pTop, valueRight(), pTop + mRowHeight] into tDisplayRect
		paintText(pDataItem["display_value"], "left", tDisplayRect, true, pDataItem["selected"])

		if mReadOnly and pDataItem["value_too_large"] then
			put mInspectItemPath into tPath
			translate tPath by [mViewWidth - scrollbarWidth() - kItemPadding - mIconWidth / 2, pTop + mRowHeight / 2]
			paintIcon(tPath, tHover, pDataItem["selected"])
		end if
	end if

	// Draw the action icons
	if mReadOnly is false and (pDataItem["selected"] is true or pRow is mHoverRow) then
		variable tRight as Real
		put mViewWidth - scrollbarWidth() - kItemPadding into tRight

		put mDeleteItemPath into tPath
		translate tPath by [tRight - mIconWidth / 2, pTop + mRowHeight / 2]
		paintIcon(tPath, tHover and mHoverIcon is "delete", pDataItem["selected"])
		
		subtract kItemPadding + mIconWidth from tRight
		
		put mAddItemPath into tPath
		translate tPath by [tRight - mIconWidth / 2, pTop + mRowHeight / 2]
		paintIcon(tPath, tHover and mHoverIcon is "add", pDataItem["selected"])
	end if
end handler

public handler OnMouseDown() returns nothing
	// Notify the scrollbar of a mouse down
	checkScrollbarMouseDown()
	
	// If there is a separator, check whether the mousedown was within kSeparatorWidth of the middle of it
	if mShowValues and mShowSeparator then		
		if the mouse position is within separatorRectangle() then
			put true into mSeparatorDragging
		end if
	end if
	
	if mSeparatorDragging or scrollDragging() then
		put 0 into mMouseDownRow
	else
		put yPosToRowNumber(the y of the mouse position) into mMouseDownRow
	end if
	put false into mScrolledSinceMouseDown
end handler

public handler OnMouseMove() returns nothing
	if scrollDragging() then
		variable tScrollPositionRatio as Real
		scrollbarDrag(mViewHeight)
		put scrollRatio(mViewHeight) into tScrollPositionRatio
	
		// Calculate the new top position of list
		put (mDataHeight - mViewHeight) * tScrollPositionRatio into mViewTopPosition
	
		ensureViewTopPosition()
		updateFirstDataItem()
		updateScrollbar(mViewWidth, mViewHeight, mDataHeight, mViewTopPosition)
		redraw all
	else if mSeparatorDragging then
		// If the separator is being dragged, update the ratio as the mouse moves
		variable tNewRatio as Number
		put (the x of the mouse position - kItemPadding) / availableSeparatorSpace() into tNewRatio
		if tNewRatio < 0 then
			put 0 into tNewRatio
		else if tNewRatio > 1 then
			put 1 into tNewRatio
		end if
		setSeparatorRatio(tNewRatio)
	else
		variable tRedraw as Boolean
		put false into tRedraw
		variable tNewHoverRow as Integer
		put yPosToRowNumber(the y of the mouse position) into tNewHoverRow
		if mHoverRow is not tNewHoverRow then
			put tNewHoverRow into mHoverRow
			put true into tRedraw
		end if
		if mHoverRow is 1 then
			put "" into mHoverIcon
		else
			variable tHoverIcon as String
			put xPosToIconString(the x of the mouse position, mHoverRow) into tHoverIcon
			if mHoverIcon is not tHoverIcon then
				put tHoverIcon into mHoverIcon
				put true into tRedraw
			end if
			setHoverTooltip(tHoverIcon)
		end if

		if tRedraw then
			redraw all
		end if
	end if
end handler

public handler onMouseLeave() returns nothing
	put 0 into mHoverRow
	redraw all
end handler

public handler OnMouseUp() returns nothing
	scrollbarMouseUp()
end handler

public handler OnMouseCancel() returns nothing
	scrollbarMouseUp()
end handler

public handler OnMouseScroll(in pDeltaX as Real, in pDeltaY as Real) returns nothing
	if mViewHeight < mDataHeight then
		variable tOldTop as Real
		put mViewTopPosition into tOldTop
	
		if pDeltaY < 0 then
			subtract mRowHeight from mViewTopPosition
		else
			add mRowHeight to mViewTopPosition
		end if
	
		ensureViewTopPosition()
		
		// If nothing changed, don't update anything
		if mViewTopPosition is tOldTop then
			return
		end if
		
		updateFirstDataItem()
		updateScrollbar(mViewWidth, mViewHeight, mDataHeight, mViewTopPosition)
		
		redraw all
	end if
end handler

public handler OnClick() returns nothing
	if mHoverRow < 1 then
		put yPosToRowNumber(the y of the mouse position) into mHoverRow
	end if

	// Click in the scrollbar region does nothing
	if the x of the click position > mViewWidth - scrollbarWidth() then
		return
	end if

	// Click on the separator does nothing
	if mShowValues and mShowSeparator then
		if mSeparatorDragging then
			put false into mSeparatorDragging
			return
		else if the click position is within separatorRectangle() then
			return
		end if
	end if	

	// Just return if mouseDown and mouseUp are not in the same row
	if mHoverRow is not mMouseDownRow then
		return
	end if

	// Just return if top position has changed (view was scrolled)
	if mScrolledSinceMouseDown then
		return
	end if
	
	// If the first row was clicked then add a new element
	if mHoverRow is 1 then
		addBaseLevelElement()
		return
	end if
	
	// Just return if the click was below all the data
	if mHoverRow > the number of elements in mDataList then
		return
	end if
	
	variable tData as Array	
	put element mHoverRow of mDataList into tData
	
	// Check if the delete icon was clicked
	if mHoverIcon is "delete" then
		variable tPrompt as String
		variable tPath
		put tData["path"] into tPath
		combine tPath with "]["
		put "Really delete array element at path [" & the result & "]?" into tPrompt
		execute script "answer \q" & tPrompt & "\q with \qOK\q and \qCancel\q; return it"
		if the result is "OK" then
			removePath(tData["path"])
		end if
		return
	end if
	
	// Check if the add icon was clicked
	if mHoverIcon is "add" then
		addUnderPath(tData["path"])
		return
	end if

    variable tPathString as String
    if mHoverIcon is "inspect" then
        combine tData["path"] with mPathDelimiter into tPathString
        post "actionInspect" with [tPathString]
        return
    end if

	// Check if the arrow was clicked
	if not tData["leaf"] then
		variable tLeft as Real
		put tData["indent"] * mIndentPixels into tLeft
		
		variable tX as Real
		put the x of the click position into tX
		
		if tX > tLeft and tX < tLeft + mIconWidth + 2 * kItemPadding then
			// Only register a click on the arrow if it is showing in front of the separator
			if not (mShowValues and mShowSeparator) or tX < the left of separatorRectangle() then
				if tData["folded"] is true then
					unfoldPath(tData["path"])
				else
					foldPath(tData["path"])
				end if
				return
			end if
		end if
	end if
	
	if the click count is 1 then
		if tData["selected"] is true then
			unselectPath(tData["path"])
		else
			selectPath(tData["path"])
		end if
		return
	end if

	if the click count > 1 then
		if tData["leaf"] then
			combine tData["path"] with mPathDelimiter into tPathString
			post "actionDoubleClick" with [tPathString]
		else
			if tData["folded"] is true then
				unfoldPath(tData["path"])
			else
				foldPath(tData["path"])
			end if
		end if
	end if
end handler

private handler yPosToRowNumber(in pYPos as Number) returns Integer
    variable tRow as Number
    put the floor of ((mViewTopPosition + pYPos) / mRowHeight + 1) into tRow
    if mReadOnly then
        add 1 to tRow
    end if

    return tRow
end handler

private handler xPosToIconString(in pXPos as Number, in pRow as Number) returns String
    variable tLeft as Real
    variable tRight as Real
    put mViewWidth - scrollbarWidth() into tRight
    
    if pXPos > tRight then
    	return ""
    end if
    
    if mReadOnly then
	    put tRight - kItemPadding - mIconWidth into tLeft
	else
		put tRight - 2 * kItemPadding - 2 * mIconWidth into tLeft
	end if
    
    if pXPos <= tLeft then
    	return ""
    end if

	if not mReadOnly then
	    if pXPos > tLeft and pXPos <= tLeft + mIconWidth then
    	    return "add"
	    end if

		return "delete"
	end if
	
	if pRow is 0 or pRow > mDataCount then
		return ""
	end if

	variable tElement as Array
	put element pRow of mDataList into tElement

	if tElement["leaf"] and tElement["value_too_large"] then
		return "inspect"
	end if
	
    return ""
end handler

public handler OnGeometryChanged()
	// Only resizing necessitates a recalculation
	if my height is not mViewHeight or my width is not mViewWidth then
		put true into mRecalculate
		put true into mRecalculateFit
	end if
end handler

private handler SetHoverTooltip(in pIconString as String) returns nothing
    if mOldTooltip is nothing or \
        (property "tooltip" of my script object is not "Add new array key" and \
        property "tooltip" of my script object is not "Delete array key") then
            put property "tooltip" of my script object into mOldTooltip
    end if

    variable tTooltip as String
    if pIconString is "delete" then
        put "Delete array key" into tTooltip
    else if pIconString is "add" then
        put "Add new array key" into tTooltip
    else
        put mOldTooltip into tTooltip
    end if
    set property "tooltip" of my script object to tTooltip
end handler

private handler UpdateIconRects() returns nothing
	put path "M0,7.421V0.21c0-0.168,0.188-0.268,0.327-0.174l5.351,3.605c0.124,0.083,0.124,0.265,0,0.348L0.327,7.595 C0.188,7.689,0,7.589,0,7.421z" into mFoldedArrowPath
	put path "M0.221,0l7.565,0c0.177,0,0.281,0.188,0.183,0.327L4.186,5.679c-0.087,0.124-0.278,0.124-0.366,0L0.038,0.327 C-0.061,0.188,0.044,0,0.221,0z" into mUnfoldedArrowPath
	put path "M512 736L512 1312Q512 1326 503 1335 494 1344 480 1344L416 1344Q402 1344 393 1335 384 1326 384 1312L384 736Q384 722 393 713 402 704 416 704L480 704Q494 704 503 713 512 722 512 736ZM768 736L768 1312Q768 1326 759 1335 750 1344 736 1344L672 1344Q658 1344 649 1335 640 1326 640 1312L640 736Q640 722 649 713 658 704 672 704L736 704Q750 704 759 713 768 722 768 736ZM1024 736L1024 1312Q1024 1326 1015 1335 1006 1344 992 1344L928 1344Q914 1344 905 1335 896 1326 896 1312L896 736Q896 722 905 713 914 704 928 704L992 704Q1006 704 1015 713 1024 722 1024 736ZM1152 1460L1152 512 256 512 256 1460Q256 1482 263 1500.5 270 1519 277.5 1527.5 285 1536 288 1536L1120 1536Q1123 1536 1130.5 1527.5 1138 1519 1145 1500.5 1152 1482 1152 1460ZM480 384L928 384 880 267Q873 258 863 256L546 256Q536 258 529 267ZM1408 416L1408 480Q1408 494 1399 503 1390 512 1376 512L1280 512 1280 1460Q1280 1543 1233 1603.5 1186 1664 1120 1664L288 1664Q222 1664 175 1605.5 128 1547 128 1464L128 512 32 512Q18 512 9 503 0 494 0 480L0 416Q0 402 9 393 18 384 32 384L341 384 411 217Q426 180 465 154 504 128 544 128L864 128Q904 128 943 154 982 180 997 217L1067 384 1376 384Q1390 384 1399 393 1408 402 1408 416Z" into mDeleteItemPath
	put path "M1408 608L1408 800Q1408 840 1380 868 1352 896 1312 896L896 896 896 1312Q896 1352 868 1380 840 1408 800 1408L608 1408Q568 1408 540 1380 512 1352 512 1312L512 896 96 896Q56 896 28 868 0 840 0 800L0 608Q0 568 28 540 56 512 96 512L512 512 512 96Q512 56 540 28 568 0 608 0L800 0Q840 0 868 28 896 56 896 96L896 512 1312 512Q1352 512 1380 540 1408 568 1408 608Z" into mAddItemPath
	put path "M1408 928L1408 1248Q1408 1367 1323.5 1451.5 1239 1536 1120 1536L288 1536Q169 1536 84.5 1451.5 0 1367 0 1248L0 416Q0 297 84.5 212.5 169 128 288 128L992 128Q1006 128 1015 137 1024 146 1024 160L1024 224Q1024 238 1015 247 1006 256 992 256L288 256Q222 256 175 303 128 350 128 416L128 1248Q128 1314 175 1361 222 1408 288 1408L1120 1408Q1186 1408 1233 1361 1280 1314 1280 1248L1280 928Q1280 914 1289 905 1298 896 1312 896L1376 896Q1390 896 1399 905 1408 914 1408 928ZM1792 64L1792 576Q1792 602 1773 621 1754 640 1728 640 1702 640 1683 621L1507 445 855 1097Q845 1107 832 1107 819 1107 809 1097L695 983Q685 973 685 960 685 947 695 937L1347 285 1171 109Q1152 90 1152 64 1152 38 1171 19 1190 0 1216 0L1728 0Q1754 0 1773 19 1792 38 1792 64Z" into mInspectItemPath

	variable tSize as Integer
	put the rounded of (mIconHeight / 2) into tSize
	put rectangle [-tSize,-tSize,tSize,tSize] into mIconRect
	
	constrainPathToRect(mIconRect, mFoldedArrowPath)
	constrainPathToRect(mIconRect, mUnfoldedArrowPath)
	constrainPathToRect(mIconRect, mDeleteItemPath)
	constrainPathToRect(mIconRect, mAddItemPath)
	constrainPathToRect(mIconRect, mInspectItemPath)

	put the width of mIconRect into mIconWidth
	put mIconWidth + 5 into mIndentPixels
end handler

--------------------------------------------------------------------------------
--
--		Display calculations
--
--------------------------------------------------------------------------------

// Clamp mViewTopPosition
private handler ensureViewTopPosition()
	variable tMinTop as Real
	put 0 into tMinTop

	// Make sure we don't try to scroll above 0
	if mViewTopPosition < tMinTop then 
		put tMinTop into mViewTopPosition
	// Make sure we don't try to scroll past the last displayable item
	else if mDataHeight > mViewHeight and mViewTopPosition > mDataHeight - mViewHeight then
		put mDataHeight - mViewHeight into mViewTopPosition
	else if mDataHeight < mViewHeight then
		put tMinTop into mViewTopPosition
	end if
end handler

// Adjust mViewTopPosition to ensure pListElt is visible
private handler ensureElementInView(in pListElt as Integer)
	variable tViewCount as Integer
	put the ceiling of (mViewHeight / mRowHeight) into tViewCount
	if mReadOnly then
		subtract 1 from pListElt
		subtract 1 from mFirstDataItem
	end if
	if pListElt <= mFirstDataItem then
		put (pListElt - 1) * mRowHeight into mViewTopPosition
	else if pListElt >= (mFirstDataItem + tViewCount - 1) then
		variable tTopOffset
		put mViewHeight mod mRowHeight into tTopOffset
		put (pListElt - tViewCount + 1) * mRowHeight - tTopOffset into mViewTopPosition
		put 0 into mHoverRow
		put "" into mHoverIcon
	end if
	updateParameters()
end handler

// Calculate mFirstDataItem from the view position
private handler updateFirstDataItem()
	put the floor of (mViewTopPosition / mRowHeight) + 1 into mFirstDataItem
	if mFirstDataItem < 1 then
		put 1 into mFirstDataItem
	end if
	if mReadOnly then
		add 1 to mFirstDataItem
	end if
end handler

-- This is called before painting if the private variable 
-- mUpdateDataList is true.
-- It replaces the whole data list, and thus should only be called if 
-- the underlying array changes.
private handler updateDataList() returns nothing
	put convertArrayToList(mData, 0, the empty list) into mDataList
	
	push the empty array onto front of mDataList

	// Unfold unfolded before reapplying selection
	if mFoldState is not empty then
		applyFoldState(0, 1, mFoldState, mData, mDataList)
	end if	
		
	// Force reselection of previously selected path (if possible)
	if mSelectedElement is not nothing then
		if not applyToNode(selectKey, mSelectedElement, 0, 1, mDataList, mData) then
			put nothing into mSelectedElement
		end if
	end if
	put false into mUpdateDataList
	
	// If we updated the data, then the fit and params need recalculation
	put true into mRecalculateFit
	put true into mRecalculate
end handler

-- This is called before painting if either the private variable 
-- mUpdateSeparator or mRecalculateFit is true.
-- It calculates the portion of the value string that can be displayed 
-- in the available space.
-- If mRecalculateFit is true, all values are recalculated.
-- This happens when the separator is moved, font/icon sizes change,
-- and when the ReadOnly property changes.
private handler updateSeparator() returns nothing
	ensureEllipsis()
	if mReadOnly then
		put 2 * kItemPadding + mIconWidth into mRightIconMargin
	else
		put 3 * kItemPadding + 2 * mIconWidth into mRightIconMargin
	end if

	variable tValueSpace as Real
	if mShowValues and mShowSeparator then
		put valueRight() - valueLeft(keyRight()) into tValueSpace
	end if
	
	variable tWidth as Real	
	put 0 into tWidth
	
	variable tKeySpace as Real
	variable tTrimmed as Boolean
	variable tCount as Integer
	variable tElement as Array
	repeat with tCount from 2 up to mDataCount
		put mDataList[tCount] into tElement
		if elementIsProxyForMoreData(tElement) then
			-- We're beyond the calculated data
			next repeat
		end if
		variable tKeyLeft as Real
		put keyLeft(tElement) into tKeyLeft
		put keyRight() - tKeyLeft into tKeySpace

		if mRecalculateFit or "key_too_large" is not among the keys of tElement then
			variable tKeyDisplay as String
			put tElement["key"] into tKeyDisplay
			if mCharsToTrimFromKey > 0 then
				if the number of chars in tKeyDisplay <= mCharsToTrimFromKey then
					put "" into tKeyDisplay
				else
					delete char 1 to mCharsToTrimFromKey of tKeyDisplay
				end if
			end if
			if mArrayStyle then
				 put "[" & tKeyDisplay & "]" into tKeyDisplay
			end if
			if mShowValues and tElement["leaf"] then
				if tElement["string_value"] is not "" then
					subtract mEllipsisLength + 2 * kItemPadding from tKeySpace
				end if
			end if
			put displayWidth(tKeyDisplay, tKeySpace, tElement["display_key"], tTrimmed) into tWidth
			put tTrimmed into tElement["key_too_large"]
		else
			put tElement["key_too_large"] into tTrimmed
		end if
		
		if mShowValues then
			if not mShowSeparator then
				if tTrimmed then
					put true into tElement["value_too_large"]
					put "" into tElement["display_value"]
					put 0 into tValueSpace
				else
					put valueRight() - valueLeft(tKeyLeft + tWidth) into tValueSpace
				end if
			end if

			// AL-2015-07-26: [[ Bug 15752 ]] Only draw specified amount of value string
			if tElement["leaf"] then
				// Only calculate fit if we are forcing recalculation or it hasn't previously been calculated.
				if mRecalculateFit or "value_too_large" is not among the keys of tElement then
						put displayWidth(tElement["string_value"], tValueSpace, tElement["display_value"], tTrimmed) into tWidth
						put tTrimmed into tElement["value_too_large"]
				end if	
			end if
		end if
		put tElement into mDataList[tCount]
	end repeat

	put false into mRecalculateFit
	put false into mUpdateSeparator
end handler

-- This is called before painting if the private variable mRecalculate
-- is true.
private handler updateParameters() returns nothing
	variable tOldDataHeight as Real
	put mDataHeight into tOldDataHeight

	put the number of elements in mDataList into mDataCount
	if mReadOnly then
		put mRowHeight * (mDataCount - 1) into mDataHeight
	else
		put mRowHeight * mDataCount into mDataHeight
	end if
	put my height into mViewHeight
	put my width into mViewWidth

	ensureViewTopPosition()
	updateFirstDataItem()
	
	// Calculate scrollbar dimensions
	updateScrollbar(mViewWidth, mViewHeight, mDataHeight, mViewTopPosition)
	
	if mDataHeight is not tOldDataHeight then
		post "formattedHeightChanged"
	end if

	put false into mRecalculate
end handler

--------------------------------------------------------------------------------
--
--		Utilities for widget display
--
--------------------------------------------------------------------------------

constant kOverlayOpacity is 0.1
private handler paintIcon(in pPath as Path, in pHover as Boolean, in pSelected as Boolean)
	if pSelected is pHover then
		set the paint of this canvas to my foreground paint	
	else if pSelected then
		set the paint of this canvas to my background paint
	else if pHover then
		set the paint of this canvas to my highlight paint
	end if
	
	fill pPath on this canvas
end handler

private handler paintBackground(in pPath as Path)
	set the paint of this canvas to my background paint
	fill pPath on this canvas
end handler

private handler paintBorder(in pPath as Path)
	set the stroke width of this canvas to kStrokeWidth
	set the paint of this canvas to my border paint
	stroke pPath on this canvas
end handler

private handler paintRow(in pPath as Path, in pHover as Boolean, in pSelected as Boolean, in pAlternate as Boolean)
	save state of this canvas
	if pSelected then
		set the paint of this canvas to my highlight paint
	else
		set the paint of this canvas to my background paint
	end if
	fill pPath on this canvas
	
	if pHover and pSelected then			
		set the paint of this canvas to my background paint
		set the opacity of this canvas to kOverlayOpacity
		fill pPath on this canvas
	else
		if pHover then
			set the paint of this canvas to my highlight paint
			set the opacity of this canvas to kOverlayOpacity
			fill pPath on this canvas
		end if
		
		if pAlternate then
			set the paint of this canvas to my foreground paint
			set the opacity of this canvas to kOverlayOpacity
			fill pPath on this canvas
		end if
	end if
	restore state of this canvas
end handler

private handler paintText(in pText as String, in pAlignment as String, in pRect as Rectangle, in pClip as Boolean, in pSelected as Boolean)
	save state of this canvas
	if pClip then
		clip to pRect on this canvas
	end if

	if pSelected then
		set the paint of this canvas to my background paint
	else
		set the paint of this canvas to my foreground paint
	end if
	if pAlignment is "left" then
		fill text pText at left of pRect on this canvas
	else if pAlignment is "center" then
		fill text pText at center of pRect on this canvas
	else if pAlignment is "right" then
		fill text pText at right of pRect on this canvas
	end if
	
	restore state of this canvas
end handler

--------------------------------------------------------------------------------
--
--		Handlers for data management and array/list conversions
--
--------------------------------------------------------------------------------

// Given a 'path' of array keys as a list, and a value, modify xArray such that
// 	the value of xArray[element 1 of pPath][element 2 of pPath]... is pValue
// 	creating the keys if necessary
private handler setValueOnPath(in pPath as List, in pValue as any, inout xArray as Array)
	if the number of elements in pPath is 1 then
		put pValue into xArray[element 1 of pPath]
	else
		if (element 1 of pPath) is not among the keys of xArray then
			put the empty array into xArray[element 1 of pPath]
		end if
		setValueOnPath(element 2 to -1 of pPath, pValue, xArray[element 1 of pPath])
	end if
end handler

private handler getValueOnPath(in pPath as List, in pArray as Array) returns any
	if pPath is the empty list then
		return pArray
	else if (element 1 of pPath) is not among the keys of pArray then
		return the empty array
	else if the number of elements in pPath is 1 then
		return pArray[element 1 of pPath]
	else
		return getValueOnPath(element 2 to -1 of pPath, pArray[element 1 of pPath])
	end if
end handler

private handler pathIsAnArray(in pPath as List, in pArray as any) returns Boolean
	if pPath is the empty list then
		return pArray is an array
	else if (element 1 of pPath) is not among the keys of pArray then
		return false
	else if the number of elements in pPath is 1 then
		return pArray[element 1 of pPath] is an array
	else
		return pathIsAnArray(element 2 to -1 of pPath, pArray[element 1 of pPath])
	end if
end handler

-- Used to validate user input as a valid path
-- An empty path is generally used to clear the selected row
private handler pathIsValid(in pPath as List, in pArray as any) returns Boolean
	if pPath is the empty list or not(pArray is an array) then
		return false
	else if (element 1 of pPath) is not among the keys of pArray then
		return false
	else if the number of elements in pPath is 1 then
		return true
	else
		return pathIsValid(element 2 to -1 of pPath, pArray[element 1 of pPath])
	end if
end handler

// Return the whole stored array
private handler getArrayData() returns Array
	return mData
end handler

private handler getFoldState() returns Array
	return mFoldState
end handler

-- Sorts numerically, converting strings to numbers where possible
private handler CompareKeysNumeric(in pLeft as any, in pRight as any) returns Integer
	variable tLeft as optional any
	variable tRight as optional any
	
	if pLeft is a number then
		put pLeft into tLeft
	else
		put pLeft parsed as number into tLeft
	end if
	
	if pRight is a number then
		put pRight into tRight
	else
		put pRight parsed as number into tRight
	end if

	if tRight is tLeft then
		-- Either both values are non-numbers or the numbers match but
		-- hash as separate entries due to leading/trailing zeros
		-- (e.g. 01.10).  In either case, sort the actual values.
		put pLeft into tLeft
		put pRight into tRight

	else -- always group numbers ahead of non-numbers
		if tRight is nothing then
			return -1
		end if
		
		if tLeft is nothing then
			return 1
		end if
	end if
	
	if tLeft < tRight then
		if mSortAscending then
			return -1
		else
			return 1
		end if
	end if
	
	if mSortAscending then
		return 1
	else
		return -1
	end if
end handler

// Taken from the MCStringEncoding enum
constant kUTF8Encoding is 4

foreign handler MCStringDecode(in BinaryData as Data, in Encoding as LCUInt, in ExternalRep as CBool, out Value as String) returns CBool binds to "<builtin>"

// Temporary wrapper to allow conversion of data to string until it is implemented in the LCB stdlib
private handler ConvertToString(in pData as Data, out rString as optional String) returns Boolean
    unsafe
        return MCStringDecode(pData, kUTF8Encoding, false, rString)
    end unsafe
end handler

private handler addToListBuffer(in pAt as Integer, in pElement as Array, inout xList as List)	
	variable tSorted as List
	put pElement["more_data"] into tSorted
	
	variable tPath as List
	if the number of elements in pElement["path"] is 1 then
		put the empty list into tPath
	else
		put element 1 to -2 of pElement["path"] into tPath
	end if
	
	variable tArray as Array
	put getValueOnPath(tPath, mData) into tArray
	
	variable tLevel as Integer
	put pElement["indent"] into tLevel
	
	delete element pAt of xList
	splice calculateMoreElements(kRowBuffer, tLevel, tPath, tSorted, tArray) after element pAt - 1 of xList
end handler

private handler calculateMoreElements(in pLimit as Integer, in pLevel as Integer, in pPath as List, in pSortedKeys as List, in pArray as Array) returns List
	variable tKey as String
	variable tElement as Array
	variable tCount as Integer
	variable tKeyCount as Integer
	put the number of elements in pSortedKeys into tKeyCount
	
	put the minimum of tKeyCount and pLimit into pLimit
	
	variable tList as List
	repeat with tCount from 1 up to pLimit
		variable tKey as String
		put pSortedKeys[tCount] into tKey
		
		variable tElement as Array
		put the empty array into tElement
		put pLevel into tElement["indent"]
	
		variable tPath as List
		put pPath into tPath
		push tKey onto tPath
		put tPath into tElement["path"]
		if tCount is pLimit and pLimit < tKeyCount then
			-- If we've calculated the max in one go, store the data
			put element tCount to tKeyCount of pSortedKeys into tElement["more_data"]
			push tElement onto tList
			return tList
		end if
	
		put tKey into tElement["key"]
		put false into tElement["selected"]
	
		if pArray[tKey] is an array then
			put false into tElement["leaf"]
			put true into tElement["folded"]
		else
			put true into tElement["leaf"]
			put pArray[tKey] into tElement["value"]
			variable tString as optional String			
			if pArray[tKey] is nothing then
				put "" into tString
			else if pArray[tKey] is a string then
				put pArray[tKey] into tString
			else if pArray[tKey] is a boolean then
				format pArray[tKey] as string into tString
			else if pArray[tKey] is a number then
				format pArray[tKey] as string into tString
			else if pArray[tKey] is a data then
				if not ConvertToString(pArray[tKey], tString) then
					put "Can't display value" into tString
				end if
			else
				put "Can't display value" into tString
			end if	
			put tString into tElement["string_value"]
		end if
		push tElement onto tList
	end repeat
	return tList
end handler

-- Convert an array to a list, as used by this widget. Ignoring the
-- 'folded' and selected parameters, mDataList should always be the 
-- result of calling this on mData
private handler convertArrayToList(in pArray as Array, in pLevel as Integer, in pPath as List) returns List

	if pArray is empty then
		return the empty list
	end if
	
	variable tKeys as List
	put the keys of pArray into tKeys
	
	if mSortNumeric then
		sort tKeys using handler CompareKeysNumeric
	else
		if mSortAscending then
			sort tKeys in ascending order
		else
			sort tKeys in descending order
		end if
	end if
	variable tViewCount as Integer
	put the ceiling of (mViewHeight / mRowHeight) into tViewCount
	return calculateMoreElements(kRowBuffer + tViewCount, pLevel, pPath, tKeys, pArray)
end handler

// A handler type for passing into 'applyToNode'
handler type NodeApply(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)

// A handler of type NodeApply to pass into 'applyToNode' - unselects the key on the given path
private handler unselectKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	put false into xList[pListElt]["selected"]
	put nothing into mSelectedElement
end handler

// A handler of type NodeApply to pass into 'applyToNode' - selects the key on the given path
private handler selectKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	put true into xList[pListElt]["selected"]
	put pPath into mSelectedElement
	if mScrollHilitedElementIntoView then
		ensureElementInView(pListElt)
	end if
end handler

// A handler of type NodeApply to pass into 'applyToNode' - removes the key on the given path
private handler removeKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	if not xList[pListElt]["leaf"] then
		foldKey(pListElt, pPath, pLevel, xList, xArray)
	end if
	delete element pListElt of xList
	delete xArray[element pLevel + 1 of pPath]
end handler

private handler createNewKey(inout xArray as Array)
	variable tNewKey as String
	variable tNew as Integer
	put 1 into tNew
	repeat while (tNew formatted as string) is among the keys of xArray
		add 1 to tNew
	end repeat
	put tNew formatted as string into tNewKey
	put "" into xArray[tNewKey]
	put tNewKey into mLastKeyAdded
end handler

private handler addBaseLevelElement()
	createNewKey(mData)
	if mHiliteNewElement then
		put the empty list into mSelectedElement
		push mLastKeyAdded onto mSelectedElement
	end if
	setArrayData(mData)
	post "dataChanged"
	if mHiliteNewElement then
		post "hiliteChanged"
	end if
end handler

// A handler of type NodeApply to pass into 'applyToNode' - adds a new key below the given path
private handler addKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	if not xList[pListElt]["leaf"] then
		foldKey(pListElt, pPath, pLevel, xList, xArray)
	end if

	variable tElement
	put xArray[pPath[pLevel + 1]] into tElement

	if tElement is an array then
		createNewKey(xArray[pPath[pLevel + 1]])
	else
		if tElement is not "" then
			variable tPrompt as String
			combine pPath with "]["
			put "The array element at path [" & the result & "] is not empty. " & \
					"Would you like to replace it with an empty array or " & \
					"move it to the first element?" into tPrompt
			execute script "answer \q" & tPrompt & \
					"\q with \qCancel\q or \qReplace\q or \qMove\q; return it"
			if the result is "Replace" then
				put "" into tElement
			else if the result is "Cancel" then
				return
			end if
		end if
		variable tArray as Array
		put the empty array into tArray	
		put tElement into tArray[1 formatted as string]
		put tArray into xArray[pPath[pLevel + 1]]
		put false into xList[pListElt]["leaf"]
		put 1 formatted as string into mLastKeyAdded
	end if

	unfoldKey(pListElt, pPath, pLevel, xList, xArray)
end handler

// Update the fold state on the given node, and below
private handler updateFoldState(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, in pArray as Array, in pFold as Boolean)
	// Update the fold state
	variable tPath as List
	put the empty list into tPath
	variable tKey as String
	repeat for each element tKey in pPath
		push tKey onto tPath
		push "array" onto tPath
	end repeat
	put "folded" into element -1 of tPath
	setValueOnPath(tPath, pFold, mFoldState)
	
	variable tArray as Array
	put mFoldState into tArray
	repeat for each element tKey in element 1 to -2 of tPath
		put tArray[tKey] into tArray
	end repeat
	
	applyFoldStateKey(element pLevel + 1 of pPath, pLevel, pListElt - 1, tArray, pArray[element pLevel + 1 of pPath], xList)
end handler

// A handler of type NodeApply to pass into 'applyToNode' - unfolds the array value on the given path
private handler unfoldKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	updateFoldState(pListElt, pPath, pLevel, xList, xArray, false)
end handler

// A handler of type NodeApply to pass into 'applyToNode' - folds the array value on the given path
private handler foldKey(in pListElt as Integer, in pPath as List, in pLevel as Integer, inout xList as List, inout xArray as Array)
	updateFoldState(pListElt, pPath, pLevel, xList, xArray, true)
end handler

// Delete the array key on the given path and update the display list
private handler removePath(in pPath as List)
	// Unselect the existing selection if applicable
	if mSelectedElement is not nothing and mSelectedElement begins with pPath then
		applyToNode(unselectKey, mSelectedElement, 0, 1, mDataList, mData)
	end if

	if applyToNode(removeKey, pPath, 0, 1, mDataList, mData) then
		post "dataChanged"
		put true into mRecalculate
		redraw all
	end if
end handler

private handler addUnderPath(in pPath as List)
	if applyToNode(addkey, pPath, 0, 1, mDataList, mData) then
		post "dataChanged"
		put true into mRecalculate
		put true into mUpdateSeparator
		if mHiliteNewElement then
			push mLastKeyAdded onto pPath
			selectPath(pPath)
		else
			redraw all
		end if
	end if
end handler

// Unfold the key at the target path
private handler unfoldPath(in pPath as List)
	if applyToNode(unfoldKey, pPath, 0, 1, mDataList, mData) then
		// Changing fold state makes a recalculation necessary
		put true into mRecalculate	
		put true into mUpdateSeparator
		if mRedraw then
			put false into mFoldChanged
			redraw all
		end if
	end if
end handler

// Ensure all elements in a path are unfolded
private handler unfoldFullPath(in pPath as List)
	variable tTopPath as List
	if mFirstDataItem > 1 then
		put mDataList[mFirstDataItem]["path"] into tTopPath
	end if

	variable tElement as Integer
	put false into mRedraw
	repeat with tElement from 1 up to the number of elements in pPath
		unfoldPath(element 1 to tElement of pPath)
	end repeat
	put true into mRedraw

	if mFoldChanged and not(mScrollHilitedElementIntoView) and \
			mFirstDataItem > 1 and \
			mDataList[mFirstDataItem]["path"] is not tTopPath then
		variable tCount as Integer
		repeat with tCount from mFirstDataItem + 1 up to the number of elements in mDataList
			if mDataList[tCount]["path"] is tTopPath then
				variable tViewCount as Integer
				put the ceiling of (mViewHeight / mRowHeight) into tViewCount
				put 1 into mFirstDataItem
				ensureElementInView(tCount + tViewCount - 1)
				exit repeat
			end if
		end repeat
	end if
end handler

// Fold the key at the target path
private handler foldPath(in pPath as List)
	if applyToNode(foldKey, pPath, 0, 1, mDataList, mData) then
		// Changing fold state makes a recalculation necessary
		put true into mRecalculate
		put true into mUpdateSeparator
		redraw all
	end if
end handler

// Select the key at the target path
private handler selectPath(in pPath as List)
	variable tPathNotAlreadySelected as Boolean
	put mSelectedElement is not pPath into tPathNotAlreadySelected
	
	variable tSelectedElement as optional List
	put mSelectedElement into tSelectedElement

	// Unselect the existing selection if applicable
	if mSelectedElement is not nothing and tPathNotAlreadySelected then
		applyToNode(unselectKey, mSelectedElement, 0, 1, mDataList, mData)
	end if

	if mSelectedElement is nothing or tPathNotAlreadySelected or \
			mScrollHilitedElementIntoView or mFoldChanged then
		put false into mFoldChanged
		if not applyToNode(selectKey, pPath, 0, 1, mDataList, mData) then
			put nothing into mSelectedElement
		end if
		if tPathNotAlreadySelected then
			post "hiliteChanged"
		end if
		redraw all
	end if
end handler

// Unselect the key at the target path
private handler unselectPath(in pPath as List)
	if mSelectedElement is not nothing and mSelectedElement is pPath then
		applyToNode(unselectKey, pPath, 0, 1, mDataList, mData)
		post "hiliteChanged"
		redraw all
	end if
end handler

// Recursive implementation of performing an action to the node at the end of the given path. 
// Acts on a list (in the format used by this widget) and an array simultaneously.
// We are quite lax with checking here, since this will only be used internally 
// 	after a delete action happens, and so the element should exist by definition.
// If the specified path doesn't exist, this returns false
private handler applyToNode(in pHandler as NodeApply, in pPathToNode as List, in pLevel as Integer, in pStart as Integer, inout xList as List, inout xArray as Array) returns Boolean	
	if pStart >= the number of elements in xList then
		return false
	end if

	variable tKey as String
	put element pLevel + 1 of pPathToNode into tKey

	variable tCount as Integer
	variable tElement as Array
	repeat with tCount from pStart + 1 up to the number of elements in xList
		put xList[tCount] into tElement
		if elementIsProxyForMoreData(tElement) then
			next repeat
		end if
		
		if tElement["key"] is tKey and pLevel is tElement["indent"] then
			if the number of elements in pPathToNode is pLevel + 1 then
				pHandler(tCount, pPathToNode, pLevel, xList, xArray)
			else if not tElement["leaf"] then
				applyToNode(pHandler, pPathToNode, pLevel + 1, tCount, xList, xArray[tKey])			
			end if
			return true
		end if	
	end repeat
	return false
end handler

// Remove all elements below pStart in the list that have a greater indent
private handler deleteSubElements(in pStart as Integer, in pTopIndent as Integer, inout xList as List)
	variable tLastSubElement as Integer
	variable tFirstSubElement as Integer
	put pStart + 1 into tFirstSubElement
	// Do if there are no more elements in the list, make sure nothing happens
	put pStart into tLastSubElement			
	variable tSubCount
	repeat with tSubCount from tFirstSubElement up to the number of elements in xList
		if xList[tSubCount]["indent"] <= pTopIndent then
			put tSubCount - 1 into tLastSubElement
			exit repeat
		end if
		put tSubCount into tLastSubElement
	end repeat
	if tFirstSubElement <= tLastSubElement then
		delete element tFirstSubElement to tLastSubElement of xList
	end if
end handler

private handler applyFoldStateKey(in pKey as String, in pLevel as Integer, in pStart as Integer, in pFoldState as Array, in pArray as Array, inout xList as List) returns Boolean

	if pStart >= the number of elements in xList then
		return false
	end if	

	variable tCount as Integer
	variable tElement as Array
	variable tPath as List
	// Find the key
	repeat with tCount from pStart + 1 up to the number of elements in xList
		put xList[tCount] into tElement
		
		if elementIsProxyForMoreData(tElement) then
			next repeat
		end if
		
		if tElement["key"] is pKey and pLevel is tElement["indent"] then
			// Either splice in the below elements
			if pFoldState["folded"] is false then
				
				if "folded" is not among the keys of xList[tCount] then
					put true into xList[tCount]["folded"]
				end if
				
				if xList[tCount]["folded"] then
					put false into xList[tCount]["folded"]
					put true into mFoldChanged
				
					splice convertArrayToList(pArray, pLevel + 1, tElement["path"]) after element tCount of xList
			
					// Apply the fold state on the subelements
					if "array" is among the keys of pFoldState then
						applyFoldState(pLevel + 1, tCount, pFoldState["array"], pArray, xList)
					end if
				end if
			// or delete them
			else
				put true into xList[tCount]["folded"] 
				deleteSubElements(tCount, tElement["indent"], xList)
			end if	
			return true
		end if	
	end repeat	
end handler

private handler applyFoldState(in pLevel as Integer, in pStart as Integer, in pFoldState as Array, in pArray as Array, inout xList as List) returns nothing

	// Find the match for each key at the appropriate level, and set folded accordingly
	variable tKey as String
	repeat for each key tKey in pFoldState
		// If this key no longer exists, don't do anything
		if tKey is not among the keys of pArray then
			next repeat
		end if
		
		// Don't apply fold if the target is now a leaf node
		if not (pArray[tKey] is an array) then
			next repeat
		end if
	
		applyFoldStateKey(tKey, pLevel, pStart, pFoldState[tKey], pArray[tKey], xList)
	end repeat

end handler

private handler checkFoldState(inout pFoldState as Array) returns Boolean
	if pFoldState is empty then
		return true
	end if
	
	variable tKey as String
	variable tValue as String
	repeat for each key tKey in pFoldState
		if not (pFoldState[tKey] is an array) or \
				"folded" is not among the keys of pFoldState[tKey] then
			return false
		end if
		if not(pFoldState[tKey]["folded"] is a boolean) then
			put pFoldState[tKey]["folded"] into tValue
			delete pFoldState[tKey]["folded"]
			if tValue is "true" then
				put true into pFoldState[tKey]["folded"]
			else
				put false into pFoldState[tKey]["folded"]
			end if
		end if
		if "array" is among the keys of pFoldState[tKey] and \
				not checkFoldState(pFoldState[tKey]["array"]) then
			return false
		end if
	end repeat
	return true
end handler

private handler setRowBackgrounds(in pShowAlternateBackgrounds as Boolean) returns nothing
	put pShowAlternateBackgrounds into mAlternateRowBackgrounds
	redraw all
end handler

--------------------------------------------------------------------------------
--
--		Properties
--
--------------------------------------------------------------------------------

// Replace the existing data wholesale with a new array pData
private handler setArrayData(in pData as Array) returns nothing
	if mAutoFoldStateReset then
		put the empty array into mFoldState
	end if
	put pData into mData
	put true into mUpdateDataList
	redraw all
end handler

private handler setFoldState(in pData as Array) returns nothing
	if not checkFoldState(pData) then
		throw "invalid fold state"
	end if
	put pData into mFoldState
	put true into mUpdateDataList
	redraw all
end handler

private handler setFrameBorder(in pFrameBorder as Boolean) returns nothing
	put pFrameBorder into mFrameBorder
	redraw all
end handler

private handler setShowHover(in pShowHover as Boolean) returns nothing
	if pShowHover is not mShowHover then
		put pShowHover into mShowHover
		redraw all
	end if
end handler

private handler getSelectedElement() returns String
	variable tElement as String
	if mSelectedElement is not nothing then
		combine mSelectedElement with mPathDelimiter into tElement
		// Make sure empty path is recognised as a valid path
		put mPathDelimiter after tElement
	else
		put the empty string into tElement
	end if
	return tElement
end handler

private handler setSelectedElement(in pElement as String)
	variable tPath as List
	split pElement by mPathDelimiter into tPath
	if pathIsValid(tPath, mData) then
		if the number of elements in tPath > 1 then
			unfoldFullPath(element 1 to -2 of tPath)
		end if
		selectPath(tPath)
	else if mSelectedElement is not nothing then
		unselectPath(mSelectedElement)
	end if
end handler

private handler getSelectedElementFoldState() returns String
	variable tFoldState as String
	put the empty string into tFoldState
	if mSelectedElement is not nothing then
		variable tCount as Integer
		repeat with tCount from 2 up to the number of elements in mDataList
			if mDataList[tCount]["selected"] then
				if mDataList[tCount]["leaf"] then
					put "leaf" into tFoldState
				else if mDataList[tCount]["folded"] then
					put "folded" into tFoldState
				else
					put "unfolded" into tFoldState
				end if
				exit repeat
			end if
		end repeat
	end if
	return tFoldState
end handler

private handler setSelectedElementFoldState(in pFoldState as String) returns nothing
	variable tSetTheFoldState as Boolean
	put (mSelectedElement is not nothing) and \
			pathIsAnArray(mSelectedElement, mData) into tSetTheFoldState
	if pFoldState is "folded" then
		if tSetTheFoldState then
			foldPath(mSelectedElement)
		end if
	else if pFoldState is "unfolded" then
		if tSetTheFoldState then
			unFoldPath(mSelectedElement)
		end if
	else
		throw "invalid fold state"
	end if
end handler

private handler getSelectedElementIsFolded() returns Boolean
	return getSelectedElementFoldState() is "folded"
end handler

private handler setSelectedElementIsFolded(in pFolded as Boolean) returns nothing
	if pFolded then
		setSelectedElementFoldState("folded")
	else
		setSelectedElementFoldState("unfolded")
	end if
end handler

private handler setReadOnly(in pReadOnly as Boolean)
	if pReadOnly is not mReadOnly then
		put pReadOnly into mReadOnly
		put true into mRecalculate
		put true into mRecalculateFit
		if pReadOnly then
			subtract mRowHeight from mViewTopPosition
		else
			add mRowHeight to mViewTopPosition
		end if
		redraw all
	end if
end handler

private handler setArrayStyle(in pArrayStyle as Boolean)
	if pArrayStyle is not mArrayStyle then
		put pArrayStyle into mArrayStyle
		put true into mRecalculateFit
		redraw all
	end if
end handler

constant kSortTypeNumeric is "numeric"
constant kSortTypeText is "text"

private handler getSortType() returns String
    if mSortNumeric then
        return kSortTypeNumeric
    else
        return kSortTypeText
    end if
end handler

private handler setSortType(in pType as String) returns nothing
    variable tSortNumeric as Boolean
    if pType is kSortTypeText then
        put false into tSortNumeric
    else if pType is kSortTypeNumeric then
        put true into tSortNumeric
    else
        throw "invalid sort type"
    end if

    if tSortNumeric is not mSortNumeric then
        put tSortNumeric into mSortNumeric
        setArrayData(mData)
    end if  

end handler

constant kSortOrderAscending is "ascending"
constant kSortOrderDescending is "descending"

private handler getSortOrder() returns String
    if mSortAscending then
        return kSortOrderAscending
    else
        return kSortOrderDescending
    end if
end handler

private handler setSortOrder(in pType as String) returns nothing
    variable tSortAscending as Boolean
    if pType is kSortOrderDescending then
        put false into tSortAscending
    else if pType is kSortOrderAscending then
        put true into tSortAscending
    else
        throw "invalid sort order"
    end if

    if tSortAscending is not mSortAscending then
        put tSortAscending into mSortAscending
        setArrayData(mData)
    end if  
end handler

private handler setCharsToTrimFromKey(in pChars as Integer) returns nothing
	if pChars < 0 then
		throw "number of leading characters to trim from key must be non-negative"
	else if pChars is not mCharsToTrimFromKey then
		put true into mRecalculateFit
		put pChars into mCharsToTrimFromKey
	end if
end handler

private handler setViewTopPosition(in pViewTopPosition as Real) returns nothing
	if pViewTopPosition is not mViewTopPosition then
		put pViewTopPosition into mViewTopPosition
		put true into mScrolledSinceMouseDown
		ensureViewTopPosition()
		updateFirstDataItem()
		updateScrollbar(mViewWidth, mViewHeight, mDataHeight, mViewTopPosition)
		redraw all
	end if
end handler

private handler setVScrollbar(in pEnabled as Boolean) returns nothing
	if pEnabled is not mVScrollbar then
		put pEnabled into mVScrollbar
		redraw all
	end if
end handler

private handler setIconHeight(in pIconHeight as Integer) returns nothing
	if pIconHeight is not mIconHeight then
		put pIconHeight into mIconHeight
		UpdateIconRects()
		put true into mRecalculateFit
	end if
end handler
--------------------------------------------------------------------------------
--
--		Movable divide
--
--------------------------------------------------------------------------------

private variable mEllipsisLength as optional Number

private handler separatorRectangle() returns Rectangle
	variable tStart as Point
	put separatorStart() into tStart

	variable tLeft as Real
	variable tTop as Real
	variable tRight as Real
	variable tBottom as Real
	put the x of tStart - kSeparatorWidth / 2 into tLeft
	put the x of tStart + kSeparatorWidth / 2 into tRight
	put the y of tStart into tTop
	put my height into tBottom
	return rectangle [tLeft, tTop, tRight, tBottom]
end handler

private handler separatorStart() returns Point
	variable tSpace as Number
	put availableSeparatorSpace() into tSpace

	variable tTop as Number
	put 0 into tTop
	if mFirstDataItem is 1 then
		add mRowHeight to tTop
	end if

	return point [tSpace * mSeparatorRatio + kItemPadding, tTop]
end handler

-- Returns the size of the space over which the separator can be moved.
private handler availableSeparatorSpace() returns Number
	ensureEllipsis()
	return mViewWidth - 4 * kItemPadding - 2 * mIconWidth - mEllipsisLength
end handler

private handler ensureEllipsis() returns nothing
	if mEllipsisLength is nothing then
		variable tEllipsis as Real
        measure "\u{2026}" on this canvas 
        put the width of the result into mEllipsisLength
	end if
end handler

-- Returns the display width of the string after fitting it in the space allowed, sets rText to 
-- the portion of the string that can fit, and sets rTrimmed if the string was trimmed.
-- There should always be space for an ellipsis after a key when there is a value.
private handler displayWidth(in pText as String, in pSpace as Real, out rText as String, out rTrimmed as Boolean) returns Real		
	variable tCount as Number
	variable tCurrentString as String
	variable tChar as String
	variable tWidth as Real
	variable tLastWidth as Real
	put mEllipsisLength into tWidth
	put "" into tCurrentString
	put 0 into tCount
	repeat for each char tChar in pText
		// Just return where we are so far if we encounter a new line character
		if tChar is newline then
			put tCurrentString & "\u{2026}" into rText		
			measure rText on this canvas
			put the width of the result into tWidth
			put true into rTrimmed
			return tWidth
		end if
		put tWidth into tLastWidth
		
		// Otherwise measure and see if what we have so far fits in the space
		put tChar after tCurrentString
		measure tCurrentString on this canvas
		
		// If it doesn't, return where we got to before.
		put the width of the result + mEllipsisLength into tWidth
		if tWidth > pSpace then
			// If we can't fit anything, just return the ellipsis.
			if tCount is 0 then
				put "\u{2026}" into rText
			else
				if (tCurrentString is pText) and (tWidth - mEllipsisLength <= pSpace) then
					put pText into rText
					put false into rTrimmed
					return tWidth - mEllipsisLength
				end if
				put (char 1 to tCount of tCurrentString) & "\u{2026}" into rText
			end if
			put true into rTrimmed
			return tLastWidth
		end if
		
		add 1 to tCount
	end repeat

	put pText into rText
	put false into rTrimmed
	return tWidth - mEllipsisLength
end handler

private handler setShowValues(in pShow as Boolean)
	if pShow is not mShowValues then
		put pShow into mShowValues
		put true into mUpdateSeparator
		put true into mRecalculateFit
		redraw all
	end if
end handler

private handler setShowSeparator(in pShow as Boolean)
	if pShow is not mShowSeparator then
		put pShow into mShowSeparator
		put true into mUpdateSeparator
		put true into mRecalculateFit
		redraw all
	end if
end handler

private handler setSeparatorRatio(in pRatio as Number)
	if pRatio < 0 or pRatio > 1 then
		throw "invalid ratio"
	end if

	if pRatio is not mSeparatorRatio then
		put pRatio into mSeparatorRatio
		put true into mRecalculateFit
		redraw all
	end if
end handler

--------------------------------------------------------------------------------
--
--		Scrollbar
--		In the future, a scrollbar will be a widget in its own right 
--		and included as a component of scrollable widgets.
--
--------------------------------------------------------------------------------

private variable mScrollbarHeight as Real
private variable mScrollbarPath as Path
private variable mScrollbarY as Real

// Drag related 
private variable mDragging as Boolean
private variable mDragStartLoc as Point
private variable mDragScrollbarOffset as Real

constant kScrollbarWidth is 5

// Will be the scrollbar's OnCreate handler
public handler initialiseScrollbar()
	put 0 into mScrollbarHeight
	put false into mDragging
end handler

// Will be the scrollbar's OnPaint handler
public handler paintScrollbar(in pCanvas as Canvas)
	// Draw scrollbar if there is any need
	if mScrollbarHeight > 0 then
		set the paint of pCanvas to my border paint
		fill mScrollbarPath on pCanvas	
	end if
end handler

// Will be the scrollbar's OnMouseDown handler
public handler checkScrollbarMouseDown()
	if mScrollbarHeight > 0 then
		put the mouse position into mDragStartLoc
		
		variable tScrollbarRect as Rectangle
		put the bounding box of mScrollbarPath into tScrollbarRect

		if mDragStartLoc is within tScrollbarRect then
			put true into mDragging
			put the y of mDragStartLoc - the top of tScrollbarRect into mDragScrollbarOffset
		end if
	end if
end handler

public handler scrollbarMouseUp()
	put false into mDragging
end handler

private handler scrollbarYFromView(in pViewHeight as Real, in pDataHeight as Real, in pTopPosition as Real) returns Real
	variable tScrollPositionRatio as Real
	put pTopPosition / (pDataHeight - pViewHeight) into tScrollPositionRatio
	return (pViewHeight - mScrollbarHeight) * tScrollPositionRatio
end handler

private handler updateScrollbar(in pViewWidth as Real, in pViewHeight as Real, in pDataHeight as Real, in pTopPosition as Real)

	variable tScrollbarHeight as Real
	variable tScrollbarRatio as Real
	
	put pViewHeight / pDataHeight into tScrollbarRatio
	
	if tScrollbarRatio >= 1 or tScrollbarRatio <= 0 then 
		put 0 into mScrollbarHeight
	else
		put pViewHeight * tScrollbarRatio into tScrollbarHeight
	
		if tScrollbarHeight < 25 then
			put 25 into mScrollbarHeight
		else
			put tScrollbarHeight into mScrollbarHeight
		end if	
		
		variable tScrollbarY as Real
		put scrollbarYFromView(pViewHeight, pDataHeight, pTopPosition) into tScrollbarY

		variable tRect as Rectangle
		put rectangle [pViewWidth - 10, 0, pViewWidth - 10 + kScrollbarWidth, mScrollbarHeight] into tRect
		put rounded rectangle path of tRect with radius 3 into mScrollbarPath
	
		put 0 into mScrollbarY
		setScrollbarY(tScrollbarY)
	end if	
end handler

private handler setScrollbarY(in pScrollbarY as Real)
	variable tScrollbarMove as Real
	put pScrollbarY - mScrollbarY into tScrollbarMove
	translate mScrollbarPath by [0, tScrollbarMove]
	put pScrollbarY into mScrollbarY
end handler

private handler scrollbarDrag(in pViewHeight as Real)
	// Get the mouse y position
	variable tMouseY as Real
	put the y of the mouse position into tMouseY
		
	if tMouseY < mDragScrollbarOffset then
		put mDragScrollbarOffset into tMouseY
	else if tMouseY > mViewHeight + mDragScrollbarOffset - mScrollbarHeight then
		put mViewHeight + mDragScrollbarOffset - mScrollbarHeight into tMouseY
	end if
		
	// Set the y of the new middle of the scrollbar
	variable tScrollbarY as Real
	put tMouseY - mDragScrollbarOffset into tScrollbarY
	setScrollbarY(tScrollbarY)
end handler

public handler scrollbarWidth() returns Real
	if mScrollbarHeight is 0 then
		return 0
	end if
	return kScrollbarWidth + 10
end handler

private handler scrollbarY() returns Real
	return mScrollbarY
end handler

private handler scrollDragging() returns Boolean
	return mDragging
end handler

private handler scrollRatio(in pViewHeight as Real)
	// Get the scrollbar space
	variable tScrollbarSpace as Real
	variable tScrollbarSpaceTop as Real
	put pViewHeight - mScrollbarHeight into tScrollbarSpace
	
	return mScrollbarY / tScrollbarSpace
end handler

end widget
