/* Copyright (C) 2003-2015 LiveCode Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

#include <foundation.h>
#include <foundation-stdlib.h>

#include "foundation-private.h"

////////////////////////////////////////////////////////////////////////////////

bool MCNativeCharsFormatV(char_t*& r_string, uindex_t& r_size, const char *p_format, va_list p_args)
{
	int t_count;
#if defined(_WINDOWS) || defined(_WINDOWS_SERVER)
	t_count = _vscprintf(p_format, p_args);
#elif defined(_MACOSX) || defined(_LINUX) || defined(TARGET_SUBPLATFORM_IPHONE) || defined(TARGET_SUBPLATFORM_ANDROID)
    va_list t_args;
    va_copy(t_args, p_args);
	t_count = vsnprintf(nil, 0, p_format, t_args);
    va_end(t_args);
#else
#error "Implement MCCStringFormat"
#endif

	char_t *t_new_string;
	if (!MCMemoryAllocate(t_count + 1, t_new_string))
		return false;

	vsprintf((char *)t_new_string, p_format, p_args);

	r_size = t_count;
	r_string = t_new_string;

	return true;
}

////////////////////////////////////////////////////////////////////////////////

compare_t MCNativeCharsCompareExact(const char_t *p_left, uindex_t p_left_length, const char_t *p_right, uindex_t p_right_length)
{
	for(;;)
	{
		if (p_left_length == 0 || p_right_length == 0)
			break;

		compare_t d;
		d = *p_left++ - *p_right++;
		if (d != 0)
			return d;

		p_left_length -= 1;
		p_right_length -= 1;
	}

	return p_left_length - p_right_length;
}

compare_t MCNativeCharsCompareCaseless(const char_t *p_left, uindex_t p_left_length, const char_t *p_right, uindex_t p_right_length)
{
	for(;;)
	{
		if (p_left_length == 0 || p_right_length == 0)
			break;

		compare_t d;
		d = MCNativeCharFold(*p_left++) - MCNativeCharFold(*p_right++);
		if (d != 0)
			return d;

		p_left_length -= 1;
		p_right_length -= 1;
	}

	return p_left_length - p_right_length;
}

bool MCNativeCharsEqualExact(const char_t *p_left, uindex_t p_left_length, const char_t *p_right, uindex_t p_right_length)
{
	if (p_left_length != p_right_length)
		return false;

	if (p_left == p_right)
		return true;

	return MCNativeCharsCompareExact(p_left, p_left_length, p_right, p_right_length) == 0;
}

bool MCNativeCharsEqualCaseless(const char_t *p_left, uindex_t p_left_length, const char_t *p_right, uindex_t p_right_length)
{
	if (p_left_length != p_right_length)
		return false;

	if (p_left == p_right)
		return true;

	return MCNativeCharsCompareCaseless(p_left, p_left_length, p_right, p_right_length) == 0;
}

////////////////////////////////////////////////////////////////////////////////

uindex_t MCNativeCharsSharedPrefixExact(const char_t *p_string, uindex_t p_string_length, const char_t *p_prefix, uindex_t p_prefix_length)
{
	uindex_t t_count;
	t_count = 0;
	for(;;)
	{
		if (p_string_length == 0 || p_prefix_length == 0)
			break;

		compare_t d;
		d = *p_string++ - *p_prefix++;
		if (d != 0)
			break;

		t_count += 1;

		p_string_length -= 1;
		p_prefix_length -= 1;
	}

	return t_count;
}

uindex_t MCNativeCharsSharedPrefixCaseless(const char_t *p_string, uindex_t p_string_length, const char_t *p_prefix, uindex_t p_prefix_length)
{
	uindex_t t_count;
	t_count = 0;
	for(;;)
	{
		if (p_string_length == 0 || p_prefix_length == 0)
			break;

		compare_t d;
		d = MCNativeCharFold(*p_string++) - MCNativeCharFold(*p_prefix++);
		if (d != 0)
			break;

		t_count += 1;

		p_string_length -= 1;
		p_prefix_length -= 1;
	}

	return t_count;
}

uindex_t MCNativeCharsSharedSuffixExact(const char_t *p_string, uindex_t p_string_length, const char_t *p_suffix, uindex_t p_suffix_length)
{
	p_string += p_string_length;
	p_suffix += p_suffix_length;

	uindex_t t_count;
	t_count = 0;
	for(;;)
	{
		if (p_string_length == 0 || p_suffix_length == 0)
			break;

		compare_t d;
		d = *--p_string - *--p_suffix;
		if (d != 0)
			break;

		t_count += 1;

		p_string_length -= 1;
		p_suffix_length -= 1;
	}

	return t_count;
}

uindex_t MCNativeCharsSharedSuffixCaseless(const char_t *p_string, uindex_t p_string_length, const char_t *p_suffix, uindex_t p_suffix_length)
{
	p_string += p_string_length;
	p_suffix += p_suffix_length;

	uindex_t t_count;
	t_count = 0;
	for(;;)
	{
		if (p_string_length == 0 || p_suffix_length == 0)
			break;

		compare_t d;
		d = MCNativeCharFold(*--p_string) - MCNativeCharFold(*--p_suffix);
		if (d != 0)
			break;

		t_count += 1;

		p_string_length -= 1;
		p_suffix_length -= 1;
	}

	return t_count;
}

////////////////////////////////////////////////////////////////////////////////

hash_t MCNativeCharsHash(const char_t *p_chars, uindex_t p_char_count, MCStringOptions p_options)
{
    bool t_fold;
    t_fold = (p_options == kMCStringOptionCompareCaseless || p_options == kMCStringOptionCompareFolded);
    
    // AL-2014-10-23: [[ Bug 13763 ]] Map native char to unichar before hashing
    unichar_t t_char;
    
    // Fowler-Noll-Vo 1a hash function
    if (sizeof(hash_t) == sizeof(uint64_t))
    {
        // 64-bit variant
        const uint64_t kPrime = 1099511628211ULL;
        const uint64_t kOffset = 14695981039346656037ULL;
        uint64_t t_hash = kOffset;
        
        while (p_char_count--)
        {
            // Hash the byte
            if (t_fold)
                t_hash ^= (uint16_t)(t_char = MCUnicodeCharMapFromNative(MCNativeCharFold(*p_chars++))) & 0xFF;
            else
                t_hash ^= (uint16_t)(t_char = MCUnicodeCharMapFromNative(*p_chars++)) & 0xFF;
            t_hash *= kPrime;
            
            // Hash the second byte of the unichar
            t_hash ^= t_char >> 8;
            t_hash *= kPrime;
        }
        return t_hash;
    }
    else
    {
        // 32-bit variant
        const uint32_t kPrime = 16777619UL;
        const uint32_t kOffset = 2166136261UL;
        uint32_t t_hash = kOffset;
        
        while (p_char_count--)
        {
            // Hash the byte
            if (t_fold)
                t_hash ^= (uint16_t)(t_char = MCUnicodeCharMapFromNative(MCNativeCharFold(*p_chars++))) & 0xFF;
            else
                t_hash ^= (uint16_t)(t_char = MCUnicodeCharMapFromNative(*p_chars++)) & 0xFF;
            t_hash *= kPrime;
            
            // Hash the second byte of the unichar
            t_hash ^= t_char >> 8;
            t_hash *= kPrime;
        }
        return t_hash;
    }

}

////////////////////////////////////////////////////////////////////////////////

void MCNativeCharsLowercase(char_t *p_chars, uindex_t p_char_count)
{
	for(uindex_t i = 0; i < p_char_count; i++)
		p_chars[i] = MCNativeCharFold(p_chars[i]);
}

void MCNativeCharsUppercase(char_t *p_chars, uindex_t p_char_count)
{
	for(uindex_t i = 0; i < p_char_count; i++)
		p_chars[i] = MCNativeCharUppercase(p_chars[i]);
}

////////////////////////////////////////////////////////////////////////////////

char_t MCNativeCharFold(char_t p_char)
{
#if defined(__WINDOWS_1252__) || defined(__ISO_8859_1__)
	static char_t kMCStringFoldWindows1252_Mapping[256] =
	{
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
		0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x9a, 0x8b, 0x9c, 0x8d, 0x9e, 0x8f,
		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xff,
		0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
		0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
		0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
		0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xd7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf,
		0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
		0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
	};
	return kMCStringFoldWindows1252_Mapping[p_char];
#elif defined(__MACROMAN__)
	static char_t kMCStringFoldMacRoman_Mapping[256] =
	{
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
		0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
		0x8a, 0x8c, 0x8d, 0x8e, 0x96, 0x9a, 0x9f, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
		0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xbe, 0xbf,
		0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
		0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0x88, 0x8b, 0x9b, 0xcf, 0xcf,
		0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd8, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
		0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0x89, 0x90, 0x87, 0x91, 0x8f, 0x92, 0x94, 0x95, 0x93, 0x97, 0x99,
		0xf0, 0x98, 0x9c, 0x9e, 0x9d, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
	};
	return kMCStringFoldMacRoman_Mapping[p_char];
#else
#error Unknown native encoding
#endif
}

char_t MCNativeCharUppercase(char_t p_char)
{
#if defined(__WINDOWS_1252__) || defined(__ISO_8859_1__)
	static char_t kMCStringUppercaseWindows1252_Mapping[256] =
	{
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
		0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x8a, 0x9b, 0x8c, 0x9d, 0x8e, 0x9f,
		0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
		0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
		0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
		0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
		0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
		0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xf7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0x9f,
	};
	return kMCStringUppercaseWindows1252_Mapping[p_char];
#elif defined(__MACROMAN__)
	static char_t kMCStringUppercaseMacRoman_Mapping[256] =
	{
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
		0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0xe7, 0xcb, 0xe5, 0x80, 0xcc, 0x81, 0x82, 0x83, 0xe9,
		0xe6, 0xe8, 0xea, 0xed, 0xeb, 0xec, 0x84, 0xee, 0xf1, 0xef, 0x85, 0xcd, 0xf2, 0xf4, 0xf3, 0x86,
		0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
		0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xae, 0xaf,
		0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xce,
		0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd9, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
		0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
		0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0x49, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
	};
	return kMCStringUppercaseMacRoman_Mapping[p_char];
#else
#error Unknown native encoding
#endif
}

char_t MCNativeCharLowercase(char_t p_char)
{
	return MCNativeCharFold(p_char);
}

////////////////////////////////////////////////////////////////////////////////

