top_srcdir=..

include $(top_srcdir)/rules/environment.linux.makefile

all: lc-compile

clean: gentle-clean lc-compile-clean mlc-clean

.PHONY: all clean

################################################################
# Bootstrap build phase control
################################################################

# Bootstrapping the compiler occurs in four stages
#
# 1. Compile the bootstrap compiler.  This supports a minimal syntax;
#    just enough to be able to compile syntax definitions.
#
# 2. Compile the full compiler.  This uses the bootstrap compiler to
#    compile syntax definitions, which are then used to build the
#    full compiler's parser.
#
# 3. Compile the full compiler again, using the compiler created in
#    stage 2.
#
# 4. Compile the full compiler again, using the compiler created in
#    stage3.  Check that the stage 3 and stage 4 results are
#    identical.

# Convenience targets
lc-compile-stage1:
	$(MAKE) STAGE=1 lc-compile
lc-compile-stage2:
	$(MAKE) STAGE=2 lc-compile
lc-compile-stage3:
	$(MAKE) STAGE=3 lc-compile
lc-compile-stage4:
	$(MAKE) STAGE=4 lc-compile

bootstrap:
	$(MAKE) STAGE=4 lc-compile
	$(MAKE) lc-compile

ifeq ($(STAGE),1)
    LC_COMPILE=false
endif

ifeq ($(STAGE),2)
    LC_COMPILE=$(CACHE_DIR)lc-compile/lc-compile-stage1
    $(LC_COMPILE): lc-compile-stage1
endif

ifeq ($(STAGE),3)
    LC_COMPILE=$(CACHE_DIR)lc-compile/lc-compile-stage2
    $(LC_COMPILE): lc-compile-stage2
endif

ifeq ($(STAGE),4)
    LC_COMPILE=$(CACHE_DIR)lc-compile/lc-compile-stage3
    $(LC_COMPILE): lc-compile-stage3
endif

# During a normal build, just grab an lc-compile from anywhere.
# Ensure that `make LC_COMPILE=/path/to/lc-compile' works properly
# too.
ifeq ($(STAGE),)
    LC_COMPILE ?= $(shell PATH=$(BUILD_DIR):$(PATH) \
	                  which lc-compile 2>/dev/null || \
	                  echo "lc-compile-missing")
    lc-compile-missing:
	@echo; \
	echo "ERROR: lc-compile not found" ; \
	echo "ERROR: Maybe you should run \`make bootstrap'" ; \
	echo; \
	false
endif

.PHONY: lc-compile-stage1 lc-compile-stage2 lc-compile-stage3
.PHONY: lc-compile-stage4 bootstrap lc-compile-missing

################################################################
# Tools
################################################################

MKDIR_P=mkdir -p
LEX=flex
YACC=bison

################################################################
# Gentle
################################################################

########## gentle program
GENTLE=$(abspath $(BUILD_DIR)/gentle)

GENTLE_srcdir=gentle/gentle-97/gentle
GENTLE_objdir=$(CACHE_DIR)gentle
GENTLE_sources=\
	cyfront.c \
	main.c \
	input.c \
	symtab.c \
	msg.c \
	output.c \
	yytab.c \
	grts.c
GENTLE_objs=$(patsubst %.c,$(GENTLE_objdir)/%.o,$(GENTLE_sources))

$(GENTLE_objs):
$(GENTLE_objdir)/%.o: $(GENTLE_srcdir)/%.c
	$(MKDIR_P) $(dir $@)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<
$(GENTLE): $(GENTLE_objs)
	$(MKDIR_P) $(dir $@)
	$(CC) $(LDFLAGS) -o $@ $^

########## gentle static library
GENTLE_LIB=$(GENTLE_objdir)/grts.o

########## reflex program
REFLEX=$(abspath $(BUILD_DIR)/reflex)
REFLEX_srcdir=gentle/gentle-97/reflex
REFLEX_objdir=$(CACHE_DIR)reflex
REFLEX_sources=\
	reflex.c
REFLEX_objs=$(patsubst %.c,$(REFLEX_objdir)/%.o,$(REFLEX_sources))

$(REFLEX_objdir)/%.o: $(REFLEX_srcdir)/%.c
	$(MKDIR_P) $(dir $@)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<
$(REFLEX): $(REFLEX_objs)
	$(MKDIR_P) $(dir $@)
	$(CC) $(LDFLAGS) -o $@ $^

########## Extra files generated by a gentle run
GENTLE_SOURCE_OUTPUTS=\
	gen.h \
	gen.y
GENTLE_REFLEX_OUTPUTS=\
	gen.lit \
	gen.tkn
REFLEX_SOURCE_OUTPUTS=\
	gen.l

gentle: $(GENTLE) $(REFLEX) $(GENTLE_LIB)

gentle-clean:
	-rm -rf $(GENTLE_objdir) $(REFLEX_objdir)
	-rm -f $(GENTLE) $(REFLEX) $(GENTLE_LIB)

.PHONY: gentle gentle-clean

################################################################
# Compiler
################################################################

########## Configuration

COMPILE_sources=\
	bind.g \
	check.g \
	generate.g \
	support.g \
	syntax.g \
	types.g \
	COMMENTS.b \
	ILLEGAL.b \
	LAYOUT.b \
	LEXDEF.b \
	LEXFUNC.b \
	LITBLOCK.b \
	SETPOS.b \
	YYSTYPE.b \
	YYWRAP.b \
	DOUBLE_LITERAL.t \
	END_OF_UNIT.t \
	INTEGER_LITERAL.t \
	NAME_LITERAL.t \
	NEXT_UNIT.t \
	SEPARATOR.t \
	STRING_LITERAL.t \
	emit.cpp \
	literal.c \
	main.c \
	operator.c \
	position.c \
	report.c \
	set.c \
	syntax-gen.c

# The name of the main syntax file to be built.  In stage 1, we have a
# minimal syntax, but in subsequent stages we generate a full syntax
# from MLC definitions.
ifeq ($(STAGE),1)
    COMPILE_grammar=grammar.g
else
    COMPILE_grammar=_stage$(STAGE)/grammar_full.g
endif

COMPILE_CPPFLAGS=$(CPPFLAGS) \
	-I$(top_srcdir)/libfoundation/include \
	-I$(top_srcdir)/libscript/include \
	-I$(COMPILE_srcdir) \
	-I$(COMPILE_stagedir)

# We can't do much about warnings that occur in the generate source
# code, so don't bother outputting them.
COMPILE_stage_CFLAGS=$(CFLAGS)
COMPILE_CFLAGS=$(CFLAGS) -Wall -std=gnu90

COMPILE_CXXFLAGS=$(CXXFLAGS) -Wall

COMPILE_LDFLAGS=$(LDFLAGS) \
	-L$(BUILD_DIR) \
	-L$(top_srcdir)/prebuilt/lib/linux/$(ARCH)

COMPILE_LDLIBS=$(LDLIBS) \
	-lscript \
	-lfoundation \
	-licui18n -licuuc -licudata \
	-ldl \
	-lffi

ifeq ($(STAGE),)
    # During final builds, turn on debugging and optimisation.  If we
    # use them in early steps, it adds additional noise that screws up
    # the bootstrap verification (because the debugging symbols
    # contain different _stageN directory names).
    COMPILE_stage_CFLAGS += -g -O3
    COMPILE_CFLAGS += -g -O3
    COMPILE_CXXFLAGS += -g -O3
else
    # Generating a build ID messes up the bootstrap verification
    # (because each binary has a UUID embedded in it).
    COMPILE_LDFLAGS += -Wl,--build-id=none
endif

########## Output executable names

# We only generate the real lc-compile program once bootstrapping is
# finished.

ifeq ($(STAGE),)
    COMPILE_exe=$(BUILD_DIR)/lc-compile
else
    COMPILE_exe=$(COMPILE_objdir)/lc-compile-stage$(STAGE)
endif

ifeq ($(STAGE),4)
    COMPILE_target=$(BUILD_DIR)/lc-compile
else
    COMPILE_target=$(COMPILE_exe)
endif


########## Rules for directories

COMPILE_stagesubdir = _stage$(STAGE)

COMPILE_objdir = $(CACHE_DIR)lc-compile
COMPILE_srcdir = lc-compile/src
COMPILE_stagedir = $(COMPILE_srcdir)/$(COMPILE_stagesubdir)

$(COMPILE_stagedir):
	$(MKDIR_P) $@

$(COMPILE_objdir): $(COMPILE_objdir)/$(COMPILE_stagesubdir)
$(COMPILE_objdir)/$(COMPILE_stagesubdir):
	$(MKDIR_P) $@


########## Rules for running gentle

COMPILE_gentle_grammars=$(filter %.g,$(COMPILE_sources) $(COMPILE_grammar))

# List of input grammars
COMPILE_gentle_inputs=\
	$(addprefix $(COMPILE_srcdir)/,\
	    $(COMPILE_gentle_grammars))

# Source files generated by gentle run
COMPILE_gentle_outputs=\
	$(addprefix $(COMPILE_stagedir)/, \
	    $(notdir $(COMPILE_gentle_inputs:.g=.c)) \
	    $(GENTLE_SOURCE_OUTPUTS) \
	    $(GENTLE_REFLEX_OUTPUTS))


# This is a bit long and involved for a couple of reasons.
#
# Firstly, you can't use normal dependencies.  .g files can refer to
# each other, and there's no way of detecting that.  So we always
# process *all* of the .g files, and use a timestamp file to indicate
# that they're up-to-date.
#
# Secondly, gentle is super picky about where it reads input files
# from.  It can't deal with input files that aren't in the current
# working directory.  Unfortunately we need to get input from two
# places: .g files might be in the main source directory, or they
# might be in the stage directory (i.e. the grammar_full.g that's
# generated by the bootstrap compiler).
#
# Since we can't put grammar_full.g in the main source directory
# (because we have different versions for stage2 and stage3), instead
# we have to copy all of the other grammar files into the stage
# directory.  Also, because grammar files can refer to each other, we
# have to copy them all over before any of them can be processed.
# Hurrah!
$(COMPILE_stagedir)/stamp-gentle: | $(GENTLE)
$(COMPILE_stagedir)/stamp-gentle: $(COMPILE_gentle_inputs)
	$(MKDIR_P) $(COMPILE_stagedir)
	@cd $(COMPILE_srcdir) && \
	for gfile in $(subst $(COMPILE_srcdir),.,$(COMPILE_gentle_inputs)); do \
	    gbase=`basename $$gfile` && \
	    if [ ! -f $(COMPILE_stagesubdir)/$$gbase ]; then \
	        echo "cp $$gfile $(COMPILE_stagesubdir)"; \
	        cp $$gfile $(COMPILE_stagesubdir) || exit $$? ; \
	    fi; \
	done
	@cd $(COMPILE_stagedir) && \
	for gfile in $(COMPILE_gentle_inputs); do \
	    gbase=`basename $$gfile` && \
	    echo "$(GENTLE) $$gbase"; \
	    $(GENTLE) $$gbase || exit $$?; \
	done
	touch $@

$(COMPILE_gentle_outputs): $(COMPILE_stagedir)/stamp-gentle

test:
	@for f in $(COMPILE_gentle_outputs); do echo $$f ; done

########## Rules for running reflex

# List of inputs to reflex
COMPILE_reflex_inputs=\
	$(addprefix $(COMPILE_srcdir)/,$(filter %.t %.b,$(COMPILE_sources))) \
	$(addprefix $(COMPILE_stagedir)/,$(GENTLE_REFLEX_OUTPUTS))

# Source files generated by reflex run
COMPILE_reflex_outputs=\
	$(addprefix $(COMPILE_stagedir)/,$(REFLEX_SOURCE_OUTPUTS))

$(COMPILE_reflex_outputs): $(COMPILE_reflex_inputs) | $(REFLEX)
	cd $(COMPILE_srcdir) && \
	$(REFLEX) -subdir $(COMPILE_stagesubdir)


########## Rules for running yacc & lex

# We can't use make's built-in rules because we end up with
# conflicting .c filenames!  make tries to create gen.c from both
# gen.l and gen.y.

%.yy.c: %.l
	$(LEX) $(LFLAGS) $< && mv lex.yy.c $@

%.tab.c: %.y
	$(YACC) $(YFLAGS) $< && mv $(notdir $@) $@

COMPILE_lex_outputs = \
	$(patsubst %.l,%.yy.c,$(filter %.l,$(COMPILE_reflex_outputs)))
COMPILE_yacc_outputs = \
	$(patsubst %.y,%.tab.c,$(filter %.y,$(COMPILE_gentle_outputs)))

.SECONDARY: COMPILE_lex_outputs COMPILE_yacc_outputs


########## Rules for compilation

COMPILE_all_sources=\
	$(filter %.cpp %.c,\
	    $(addprefix $(COMPILE_srcdir)/,$(COMPILE_sources)) \
	    $(COMPILE_gentle_outputs) \
	    $(COMPILE_reflex_outputs) \
	    $(COMPILE_lex_outputs) \
	    $(COMPILE_yacc_outputs))

COMPILE_objs=\
	$(subst $(COMPILE_srcdir),$(COMPILE_objdir),\
	    $(addsuffix .o,$(basename $(COMPILE_all_sources))))

# Use a special, quieter rule for generated source files
$(COMPILE_objdir)/$(COMPILE_stagesubdir)/%.o: $(COMPILE_stagedir)/%.c
	$(MKDIR_P) $(dir $@)
	$(CC) $(COMPILE_CPPFLAGS) $(COMPILE_stage_CFLAGS) -c -o $@ $<

$(COMPILE_objdir)/%.o: $(COMPILE_srcdir)/%.c
	$(MKDIR_P) $(dir $@)
	$(CC) $(COMPILE_CPPFLAGS) $(COMPILE_CFLAGS) -c -o $@ $<
$(COMPILE_objdir)/%.o: $(COMPILE_srcdir)/%.cpp
	$(MKDIR_P) $(dir $@)
	$(CXX) $(COMPILE_CPPFLAGS) $(COMPILE_CXXFLAGS) -c -o $@ $<

$(COMPILE_exe): $(COMPILE_objs) $(GENTLE_LIB)
	$(MKDIR_P) $(dir $@)
	$(CXX) $(COMPILE_LDFLAGS) -o$@ $^ $(COMPILE_LDLIBS)


########## Rules for bootstrapping checks

ifeq ($(STAGE),4)
    COMPILE_bootstrap_check_exes = \
	$(COMPILE_exe) $(COMPILE_exe:4=3)

    $(COMPILE_target): $(COMPILE_bootstrap_check_exes)
	for f in $(COMPILE_bootstrap_check_exes); \
	    do strip -s -o $$f-strip $$f ; \
	done
	@if ! cmp $(COMPILE_bootstrap_check_exes); then \
	    echo; \
	    echo "ERROR: Stage 4 output does not match stage 3."; \
	    echo "ERROR: There may be a bootstrapping problem."; \
	    echo; \
	    exit 1; \
	fi
	-for f in $(COMPILE_bootstrap_check_exes); do rm $$f-strip; done
	@if ! cmp $< $@; then \
	    echo "cp $< $@"; \
	    cp $< $@; \
	else \
	    echo "touch $@"; \
	    touch $@; \
	fi
endif


########## Targets

lc-compile: $(COMPILE_target)

lc-compile-clean:
	-rm -rf $(COMPILE_srcdir)/_stage* $(COMPILE_objdir)
	-rm -rf $(COMPILE)
	-rm -f $(BUILD_DIR)/lc-compile{,stage*}

.PHONY: lc-compile lc-compile-clean


################################################################
# Modular LiveCode files
################################################################

MODULEDIR=$(BUILD_DIR)/modules

########## libscript MLC

SCRIPT_mlcdir = $(top_srcdir)/libscript/src

SCRIPT_mlc = \
	arithmetic.mlc \
	array.mlc \
	binary.mlc \
	bitwise.mlc \
	byte.mlc \
	char.mlc \
	list.mlc \
	logic.mlc \
	math-foundation.mlc \
	math.mlc \
	sort.mlc \
	string.mlc \
	type-convert.mlc

########## engine MLC

ENGINE_mlcdir = $(top_srcdir)/engine/src

ENGINE_mlc = \
	canvas.mlc \
	engine.mlc \
	widget.mlc

########## LCI compilation

# It's really important that this list is in dependency order.  We
# have no way of detecting dependencies at the moment (e.g. some sort
# of makedep support in the compiler), so the MLC files must be
# ordered correctly.
ALL_mlc = \
	$(addprefix $(SCRIPT_mlcdir)/,$(SCRIPT_mlc)) \
	$(addprefix $(ENGINE_mlcdir)/,$(ENGINE_mlc))

$(COMPILE_stagedir)/stamp-lci: $(ALL_mlc)
	$(MKDIR_P) $(MODULEDIR) $(dir $@)
	@for mlcfile in $(ALL_mlc); do \
	    echo $(LC_COMPILE) -modulepath $(MODULEDIR) $$mlcfile ; \
	    $(LC_COMPILE) -modulepath $(MODULEDIR) $$mlcfile || exit $$?; \
	done
	touch $@

# In bootstrap mode, try and build the compiler.  Otherwise, just
# order after it.
ifeq ($(STAGE),)
    $(COMPILE_stagedir)/stamp-lci: | $(LC_COMPILE)
else
    $(COMPILE_stagedir)/stamp-lci: $(LC_COMPILE)
endif

########## Grammar compilation

GRAMMAR_template=$(COMPILE_srcdir)/grammar.g

GRAMMAR_inputs = $(ALL_mlc)

ifneq ($(STAGE),1)
    GRAMMAR_output = $(addprefix $(COMPILE_srcdir)/,$(COMPILE_grammar))
endif

$(GRAMMAR_output): $(COMPILE_stagedir)/stamp-lci
$(GRAMMAR_output): $(GRAMMAR_inputs) $(GRAMMAR_template)
	$(MKDIR_P) $(dir $@)
	$(LC_COMPILE) -bootstrap -template $(GRAMMAR_template) \
	    -modulepath $(MODULEDIR) -output $(GRAMMAR_output) $(GRAMMAR_inputs) > /dev/null

########## Convenience targets

lci: $(COMPILE_stagedir)/stamp-lci

mlc-clean:
	-rm -rf $(MODULEDIR)

.PHONY: lci mlc-clean
