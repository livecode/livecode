module test

public handler test()
    variable tResults as list
    put the empty list into tResults

    variable tDelimiter as string
    put newline into tDelimiter
	
	-- test test
	testLog("__Test", "Fail", false, tResults)
	testLog("__Test", "Succeed", true, tResults)
	
	-- structural
	testRepeat(tResults)
	testLogicStructural(tResults)
	
	--com.livecode.array
	testArray(tResults)	
	
	--com.livecode.typeconvert
	testTypeConvert(tResults)
	
	--com.livecode.list
    testList(tResults)
    
	--com.livecode.arithmetic
    testArithmetic(tResults)
    	
	--com.livecode.bitwise	
	testBitwise(tResults)
	
	--com.livecode.char
	testChar(tResults)
		
	--com.livecode.logic
    testLogic(tResults)
    
	--com.livecode.math
	testMath(tResults)
	
	--com.livecode.mathfoundation
	testMathFoundation(tResults)
	
	--com.livecode.sort
    testSort(tResults)
    
	--com.livecode.string
	testString(tResults)
	
	--com.livecode.type
	testType(tResults)
	
	--com.livecode.binary
	--com.livecode.byte
	--com.livecode.item
	--com.livecode.line
	--com.livecode.segmentchunk

	// put fails at the end
	sort tResults in descending order
	
    variable tResultString as string
    put the empty string into tResultString
    combine tResults with tDelimiter into tResultString

    return tResultString
end handler

public handler testLog(in pModule as string, in pTest as string, in pResult as bool, inout xResults as list)
    variable tStringResult as string
    if pResult then
        put "SUCCESS" into tStringResult
    else
        put "FAILURE" into tStringResult
    end if

    push tStringResult && ":" && pModule & "_" & pTest onto xResults
end handler

public handler boolWithSideEffect(in tResult as bool, inout tVar as string) as bool
	put "a" into tVar
	return tResult
end handler

public handler testType(inout xResults as list)

end handler

public handler testMathFoundation(inout xResults as list)

	variable tNum as number
	variable tNumReal as double
	put -5.5 into tNum
	put 5.5 into tNumReal
	
	testLog("MathFoundation", "FloorNum", the floor of tNum is -6, xResults)
	testLog("MathFoundation", "FloorReal", the floor of tNumReal is 5, xResults)
	
	testLog("MathFoundation", "CeilNum", the ceiling of tNum is -5, xResults)
	testLog("MathFoundation", "CeilReal", the ceiling of tNumReal is 6, xResults)
	
	round tNum
	round tNumReal
	
	testLog("MathFoundation", "RoundToNearestNum", tNum is -6, xResults)
	testLog("MathFoundation", "RoundToNearestReal", tNumReal is 6, xResults)
	
	testLog("MathFoundation", "RoundedToNearest", the rounded of 4.5 is 5, xResults)

end handler

public handler testMath(inout xResults as list)

	testLog("Math", "PowerOf", 3 ^ 4 = 81, xResults)
	testLog("Math", "Base10Log", the log of 1000 is 3, xResults)
	
	testLog("Math", "Sin", the sin of pi / 2 is 1, xResults)
	testLog("Math", "Cos", the cos of pi is -1, xResults)
	testLog("Math", "Tan", (the tan of pi / 4) - 1  < 0.00000000001, xResults)

	testLog("Math", "Exp", the exp of 3 > 20, xResults)
	testLog("Math", "Exp", the exp of 3 < 20.1, xResults)
	
	testLog("Math", "Ln", the natural log of 55 > 4, xResults)
	testLog("Math", "Ln", the natural log of 55 < 4.01, xResults)
	
	testLog("Math", "ExpLog", the abs of ((the natural log of the exp of 3) - 3) < 0.00000000001, xResults)
	testLog("Math", "LogExp", the abs of ((the exp of the natural log of 80) - 80) < 0.00000000001, xResults)
	
	testLog("Math", "Trunc", the trunc of 5.5 is 5, xResults)
	
	testLog("Math", "Abs", the abs of 5.5 is 5.5, xResults)
	testLog("Math", "Abs", the abs of -5.5 is 5.5, xResults)
	
	variable tNum
	put any number into tNum
	testLog("Math", "Random", tNum >= 0, xResults)
	testLog("Math", "Random", tNum <= 1, xResults)
	
	testLog("Math", "Random", tNum is not any number, xResults)

	variable tLeft as integer
	variable tRight as integer
	
	put 4 into tLeft
	put 5 into tRight
	
	testLog("Math", "Min", the min of 3 and 5 is 3, xResults)
	testLog("Math", "Min", the min of 5.5 and 5.4 is 5.4, xResults)
	
	testLog("Math", "MinInt", the min of tLeft and tRight is tLeft, xResults)
	testLog("Math", "MinInt", the min of tRight and tLeft is tLeft, xResults)
	
	testLog("Math", "Max", the max of 3 and 5 is 5, xResults)
	testLog("Math", "Max", the max of 5.5 and 5.4 is 5.5, xResults)
	
	testLog("Math", "MaxInt", the max of tLeft and tRight is tRight, xResults)
	testLog("Math", "MaxInt", the max of tRight and tLeft is tRight, xResults)

	testLog("Math", "ConvertFromBase", ("6A" converted from base 16) is 106, xResults)
	testLog("Math", "ConvertFromBase", ("1001010" converted from base 2) is 74, xResults)
	
	testLog("Math", "ConvertToBase", (7 converted to base 2) is "111", xResults)
	testLog("Math", "ConvertToBase", (500 converted to base 12) is "358", xResults)
	
	testLog("Math", "ConvertFromBaseToBase", ("1122" converted from base 4 to base 14) is "66", xResults)

end handler

public handler testTypeConvert(inout xResults as list)
	variable tString as string
	put "a,b,c,d,e" into tString
	
	variable tList as list
	split tString by "," into tList
	
	testLog("TypeConvert", "Split", tList is ["a","b", "c", "d", "e"], xResults)
	
	combine tList with "," into tString
	
	testLog("TypeConvert", "Combine", tString is "a,b,c,d,e", xResults)
	
end handler

public handler testRepeat(inout xResults as list)

	variable tString as string
	put "abcdefghijklmno" into tString
	
	variable tRestring as string
	variable tChar as string
	put "" into tRestring
	repeat for each char tChar in tString
		put tChar after tRestring
	end repeat
	
	testLog("Repeat", "RepeatChar", tString is tRestring, xResults)
	
	variable tList as list
	put [1, 1, 2, 3, 5, 8, 13] into tList
	
	variable tRelist as list
	variable tElement as any
	put the empty list into tRelist
	repeat for each element tElement in tList
		push tElement onto tRelist
	end repeat
	
	testLog("Repeat", "RepeatElement", tRelist contains tList and tList contains tRelist, xResults)

end handler

public handler testString(inout xResults as list)
	variable tString as string
	put the empty string into tString
	
	testLog("String", "EmptyString", tString is "", xResults)
	
	put "abcde" before tString
	testLog("String", "PutBeforeString", tString is "abcde", xResults)
	
	put "fghij" after tString
	testLog("String", "PutBeforeString", tString is "abcdefghij", xResults)
	
	testLog("String", "ConcatenateString", tString is "abcde" & "fghij", xResults)
	testLog("String", "ConcatenateString", "a" & "b" & "c" is "abc", xResults)
	
	testLog("String", "ConcatenateWithSpace", "ab" && "cd" is "ab cd", xResults)
	testLog("String", "ConcatenateWithSpace", "a" && "b" && "c" is "a b c", xResults)
	
	put "purple" into tString
	replace "p" with "t" in tString
	testLog("String", "ReplaceString", tString is "turtle", xResults)
	
	testLog("String", "Uppercase", the upper of "abcd" is "ABCD", xResults)
	testLog("String", "Lowercase", the lower of "ABCD" is "abcd", xResults)
	
	testLog("String", "LessThan", "!" < "A", xResults)
	testLog("String", "GreaterThan", "a" > "A", xResults)

end handler

public handler testArray(inout xResults as list)
	variable tArray as array
	put the empty array into tArray
	
	put "value1" into tArray["key1"]
	put "value2" into tArray["key2"]
	put "value3" into tArray["key3"]
	
	testLog("Array", "CountElementsOf", the number of elements in tArray is 3, xResults)
	
	variable tKeys as list
	put the keys of tArray into tKeys
	
	testLog("Array", "KeysOfCount", the number of elements in tKeys is 3, xResults)

	variable tKeysString as string
	combine tKeys with "," into tKeysString
	
	testLog("Array", "KeysOf1", tKeysString contains "key1", xResults)
	testLog("Array", "KeysOf2", tKeysString contains "key2", xResults)
	testLog("Array", "KeysOf3", tKeysString contains "key3", xResults)
		
	variable tElements as list
	put the elements of tArray into tElements
	
	testLog("Array", "ElementssOfCount", the number of elements in tElements is 3, xResults)
	
	testLog("Array", "ElementsOf1", "value1" is in tElements, xResults)
	testLog("Array", "ElementsOf2", "value2" is in tElements, xResults)
	testLog("Array", "ElementsOf3", "value3" is in tElements, xResults)
		
	--testLog("Array", "IsAmongTheKeys", "key1" is among the keys of tArray, xResults)
	--testLog("Array", "IsAmongTheElements", "value1" is among the keys of tArray, xResults)
	
	testLog("Array", "SingletonElementOf", tArray["key1"] is "value1", xResults)

    variable tNewArray as array
    put the empty array into tNewArray
    put 1 into tNewArray["abc"]
    put 2 into tNewArray["def"]
    put 3 into tNewArray["ghi"]

	variable tString as string
	put "" into tString
	
	variable tKey as string
    repeat for each key tKey in tNewArray
        put tKey after tString
    end repeat
    
    testLog("Array", "RepeatForEachKey1", tString contains "abc", xResults)
    testLog("Array", "RepeatForEachKey2", tString contains "def", xResults)
    testLog("Array", "RepeatForEachKey3", tString contains "ghi", xResults)

	variable tSum as number
	put 0 into tSum
	
	variable tElement
    repeat for each element tElement in tNewArray
        add tElement to tSum
    end repeat
    
    testLog("Array", "RepeatForEachElement", tSum is 6, xResults)

end handler

public handler testBitwise(inout xResults as list)
	variable tVar as integer
	
	put 3 bitwise and 6 into tVar
	testLog("Bitwise", "BitwiseAnd", tVar is 2, xResults)
	
	put 3 bitwise or 6 into tVar
	testLog("Bitwise", "BitwiseOr", tVar is 7, xResults)
	
	put 3 bitwise xor 6 into tVar
	testLog("Bitwise", "BitwiseXor", tVar is 5, xResults)
	
	--put bitwise not 0 into tVar

	put 7 shifted by 2 bitwise into tVar 
	testLog("Bitwise", "BitwiseShift", tVar is 28, xResults)
	
end handler

public handler testLogic(inout xResults as list)

    testLog("Logic", "Not", not false, xResults)
    testLog("Logic", "Not", not not true, xResults)
        
    testLog("Logic", "Is", true is true, xResults)
    testLog("Logic", "Is", false is false, xResults)

    testLog("Logic", "Is", true is not false, xResults)
    testLog("Logic", "Is", false is not true, xResults)
    	
    testLog("Logic", "Is", not true is false, xResults)
    testLog("Logic", "Is", not false is true, xResults)
    
end handler

public handler testLogicStructural(inout xResults as list)
    variable tString as string
    put the empty string into tString
    if (false and boolWithSideEffect(true, tString)) then
    	testLog("Logic", "And", false, xResults)
    else
        testLog("Logic", "And", true, xResults)
    end if	
    
    testLog("Logic", "AndShortCut", not (tString is "a"), xResults)
    
    if (true and boolWithSideEffect(true, tString)) then
    	testLog("Logic", "And", true, xResults)
    else
      	testLog("Logic", "And", false, xResults)  
    end if		
    
    testLog("Logic", "AndShortCut", tString is "a", xResults)
    
    variable tString2 as string
    put the empty string into tString2
    if (true or boolWithSideEffect(false, tString2)) then
    	testLog("Logic", "Or", true, xResults)
    else
        testLog("Logic", "Or", false, xResults)	
    end if	
    
    testLog("Logic", "OrShortCut", not (tString2 is "a"), xResults)
    
    if (false or boolWithSideEffect(false, tString2)) then
    	testLog("Logic", "Or", false, xResults)
    else
    	testLog("Logic", "Or", true, xResults)
    end if		
    
    testLog("Logic", "OrShortCut", tString2 is "a", xResults)	
end handler

public handler testChar(inout xResults as list)
	variable tString as string
	put "abcde" into tString
	
	testLog("Char", "CountCharsOf", the number of chars in tString is 5, xResults)
	testLog("Char", "FetchCharOf", char 5 of tString is "e", xResults)
	
	put "abcd" into char 5 of tString
	
	testLog("Char", "StoreCharOf", tString is "abcdabcd", xResults)
	
	testLog("Char", "FetchCharRangeOf", char 5 to 8 of tString is "abcd", xResults)
	
	put "e" into char 5 to 8 of tString
	
	testLog("Char", "StoreCharRangeOf", tString is "abcde", xResults)
	
	testLog("Char", "CharIsIn", "a" is in "abc", xResults)

	put "abcde" before char 1 of tString
	
	testLog("Char", "BeforeCharOf", tString is "abcdeabcde", xResults)
	
	put "abcde" after char 5 of tString
	
	testLog("Char", "AfterCharOf", tString is "abcdeabcdeabcde", xResults)

	
	testLog("Char", "BeginsWithEmpty", tString begins with "", xResults)
	testLog("Char", "BeginsWith", tString begins with "abcd", xResults)
	
	testLog("Char", "EndsWithEmpty", tString ends with "", xResults)
	testLog("Char", "EndsWith", tString ends with "bcde", xResults)

	variable tOffset as integer
	put the first offset of "abcde" in tString into tOffset
	
	testLog("Char", "CharOffset", tOffset is 1, xResults)
	
	put the first offset of "abcdef" in tString into tOffset
	testLog("Char", "CharOffset", tOffset is 0, xResults)
	
	put the offset of chars "abcde" after 1 in tString into tOffset
	
	testLog("Char", "CharOffsetAfter", tOffset is 5, xResults)
	
	put the first offset of chars "abcde" after 11 in tString into tOffset
	testLog("Char", "CharOffsetAfter", tOffset is 0, xResults)
	
	variable tLastDot as integer
	variable tAddress as string
	variable tTLD as string
	put "http://www.livecode.com/index.html" into tAddress
	put the last offset of "." in tAddress into tLastDot
	put the offset of "." before tLastDot in tAddress into tOffset
	put char tOffset + 1 to tOffset + 3 of tAddress into tTLD
	
	testLog("Char", "CharOffsetBefore", tTLD is "com", xResults)
	
	variable tVar as string
	put "123" into tVar
	
	variable tCount as integer
	put the number of chars in tVar into tCount
	subtract 1 from tCount
	
	repeat tCount times
		put "," after char tCount of tVar
		subtract 1 from tCount
	end repeat 	
	
	testLog("Char", "CharExample", tVar is "1,2,3", xResults)	
end handler

public handler testArithmetic(inout xResults as list)

	variable tInt as int
	variable tReal as double
	variable tNumber
	
	put 10 into tInt
	put 10 into tReal
	put 10 into tNumber
	
	add 2 to tInt
	add 2 to tReal
	add 2 to tNumber
	
	testLog("Arithmetic", "AddToInt", tInt is 12, xResults)
	testLog("Arithmetic", "AddToReal", tReal is 12, xResults)
	testLog("Arithmetic", "AddToNum", tNumber is 12, xResults)

	subtract 2 from tInt
	subtract 2 from tReal
	subtract 2 from tNumber
	
	testLog("Arithmetic", "SubtractFromInt", tInt is 10, xResults)
	testLog("Arithmetic", "SubtractFromReal", tReal is 10, xResults)
	testLog("Arithmetic", "SubtractFromNum", tNumber is 10, xResults)
	
	multiply tInt by 2
	multiply tReal by 2
	multiply tNumber by 2

	testLog("Arithmetic", "MultiplyInt", tInt is 20, xResults)
	testLog("Arithmetic", "MultiplyReal", tReal is 20, xResults)
	testLog("Arithmetic", "MultiplyNum", tNumber is 20, xResults)	

	divide tInt by 40
	divide tReal by 40
	divide tNumber by 40
	
	testLog("Arithmetic", "DivideInt", tInt is 0, xResults)
	testLog("Arithmetic", "DivideReal", tReal is 0.5, xResults)
	testLog("Arithmetic", "DivideNum", tNumber is 0.5, xResults)
	
	variable tLeft as int
	variable tRight as int
	
	put 10 into tLeft
	put 2 into tRight
	
	variable tLeftReal as double
	variable tRightReal as double
	
	put 10 into tLeftReal
	put 2 into tRightReal
	
	testLog("Arithmetic", "PlusInt", tLeft + tRight is 12, xResults)
	testLog("Arithmetic", "PlusReal", tLeftReal + tRightReal is 12, xResults)
	testLog("Arithmetic", "PlusNum", 10 + 2 is 12, xResults)
	
	testLog("Arithmetic", "MinusInt", tLeft - tRight is 8, xResults)
	testLog("Arithmetic", "MinusReal", tLeftReal - tRightReal is 8, xResults)	
	testLog("Arithmetic", "MinusNum", 10 - 2 is 8, xResults)
	
	testLog("Arithmetic", "TimesInt", tLeft * tRight is 20, xResults)
	testLog("Arithmetic", "TimesReal", tLeftReal * tRightReal is 20, xResults)
	testLog("Arithmetic", "TimesNum", 10 * 2 is 20, xResults)
	
	testLog("Arithmetic", "DivideInt", tLeft / tRight is 5, xResults)
	testLog("Arithmetic", "DivideReal", tLeftReal / tRightReal is 5, xResults)
	testLog("Arithmetic", "DivideNum", 10 / 2 is 5, xResults)
	
	variable tOne as int
	put 1 into tOne
	
	testLog("Arithmetic", "ModInt", tLeft mod (tRight + tOne) is 1, xResults)
	testLog("Arithmetic", "ModNum", 4^((7-1)/2) mod 7 is 1, xResults)
	
	testLog("Arithmetic", "Wrap", 5 wrap 3 is 2, xResults)
	testLog("Arithmetic", "Wrap", -3 wrap 3 is -3, xResults)
	
	testLog("Arithmetic", "GreaterThanInt", tLeft > tRight, xResults)
	testLog("Arithmetic", "GreaterThanInt", not tLeft > tLeft, xResults)
	testLog("Arithmetic", "GreaterThanNum", 2 > 1, xResults)
	testLog("Arithmetic", "GreaterThanNum", not 1 > 1, xResults)
	
	testLog("Arithmetic", "GreaterThanOrEqualToInt", tLeft >= tLeft, xResults)
	testLog("Arithmetic", "GreaterThanOrEqualToInt", not tRight >= tLeft, xResults)
	testLog("Arithmetic", "GreaterThanOrEqualToNum", 1 >= 1, xResults)
	testLog("Arithmetic", "GreaterThanOrEqualToNum", not 1 >= 2, xResults)
	
	testLog("Arithmetic", "LessThanInt", not tLeft < tLeft, xResults)
	testLog("Arithmetic", "LessThanInt", tRight < tLeft, xResults)
	testLog("Arithmetic", "LessThanNum", 1 < 2, xResults)
	testLog("Arithmetic", "LessThanNum", not 1 < 1, xResults)
	
	testLog("Arithmetic", "LessThanOrEqualToInt", tLeft <= tLeft, xResults)
	testLog("Arithmetic", "LessThanOrEqualToInt", not tLeft <= tRight, xResults)
	testLog("Arithmetic", "LessThanOrEqualToNum", 1 <= 1, xResults)
	testLog("Arithmetic", "LessThanOrEqualToNum", not 2 <= 1, xResults)
    
    testLog("Arithmetic", "CrossTypeComparison", tLeft > 5, xResults)
    testLog("Arithmetic", "CrossTypeComparison", tLeftReal > 5, xResults)
    testLog("Arithmetic", "CrossTypeComparison", tLeft >= 10, xResults)
    testLog("Arithmetic", "CrossTypeComparison", tLeftReal >= 10, xResults)
    testLog("Arithmetic", "CrossTypeComparison", tLeftReal <= tLeft, xResults)
    testLog("Arithmetic", "CrossTypeComparison", tLeft <= tLeftReal, xResults)
	
end handler

public handler testList(inout xResults as list)
    variable tTestList as list
    put the empty list into tTestList

	variable tCount as integer
	put the number of elements in tTestList into tCount
	testLog("List", "EmptyList", tCount is 0, xResults)

    push "xyz" onto tTestList
    push 2 onto tTestList
    push "abcd" onto tTestList
    push 1 onto tTestList

    testLog("List", "NumberOfElements", the number of elements in tTestList is 4, xResults)
   	testLog("List", "HeadOf", the head of tTestList is "xyz", xResults)
	testLog("List", "TailOf", the tail of tTestList is 1, xResults)

	variable tNewList as list
	put [1,2,3] into tNewList
	push 0 onto front of tNewList
	testLog("List", "PushOntoListFront", tNewList[1] is 0, xResults)
	push 4 onto back of tNewList
	testLog("List", "PushOntoListBack", tNewList[-1] is 4, xResults)
	push 5 onto tNewList
	testLog("List", "PushOntoList", tNewList[-1] is 5, xResults)
	
	put "A" into element 2 of tNewList
    testLog("List", "ElementOf", element 2 of tNewList is "A", xResults)
   	testLog("List", "ElementRangeOf1", element 2 of element 3 to -1 of tTestList is 1, xResults)
	put "ABC" into element 2 to 4 of tNewList
	testLog("List", "ElementRangeOf2", element -3 of tNewList is "ABC", xResults)

    testLog("List", "Contains", tTestList contains element -2 to -1 of tTestList, xResults)

	testLog("List", "Begins", tTestList begins with [tTestList[1], tTestList[2]], xResults)
	testLog("List", "Ends", tTestList ends with element 3 to -1 of tTestList, xResults)

    variable tSubList as list
    put element -2 to -1 of tTestList into tSubList

	testLog("List", "Is", tSubList is ["abcd", 1], xResults)
	testLog("List", "IsNot", tSubList is not ["Abcd", 1], xResults)

    testLog("List", "IsIn", "abcd" is in tSubList, xResults)
    testLog("List", "IsNotIn", not tSubList is in tTestList, xResults)

    variable tString as string
    pop front of tSubList into tString

    testLog("List", "PopList1", tString is "abcd", xResults)
    testLog("List", "PopList2", the number of elements in tSubList is 1, xResults)

	variable tElt as number
	pop front of tNewList into tElt
	testLog("List", "PopFromFront", tElt is 0, xResults)
	pop back of tNewList into tElt
	testLog("List", "PopFromBack", tElt is 5, xResults)
	
    splice tTestList after element 1 of tSubList

    testLog("List", "SpliceAfter1", the number of elements in tSubList is 5, xResults)
    testLog("List", "SpliceAfter2", the tail of tSubList is 1, xResults)
    testLog("List", "SpliceAfter3", tSubList contains tTestList, xResults)

	put "ZZZZ" into tTestList[1]
	testLog("List", "SingletonElement", tTestList[1] is "ZZZZ", xResults)

	variable tList as list
	put [1,2,3] into tList
	
	splice tList into element 1 to 3 of tList
	testLog("List", "SpliceIntoRange", tList is [1,2,3], xResults)
	splice element 1 to 2 of tList into element 1 of tList
	testLog("List", "SpliceIntoElement", tList is [1,2,2,3], xResults)
	
	splice tList before element 1 of tList
	testLog("List", "SpliceBefore", tList is [1,2,2,3,1,2,2,3], xResults)
	
	variable tAnotherList as list
	put [1,2,3] into tAnotherList	
	put tAnotherList into element 1 to 2 of tAnotherList 
	testLog("List", "ElementRangeOf3", element -2 of tAnotherList is [1,2,3], xResults)

end handler

public handler testSort(inout xResults as list)
    variable tTestList as list
    put the empty list into tTestList

    push "xyz" onto tTestList
    push 2 onto tTestList
    push "abcd" onto tTestList
    push 1 onto tTestList
    
    sort tTestList in ascending numeric order

    testLog("Sort", "AscendingNumeric", the head of tTestList is 1, xResults)
    testLog("Sort", "NumericStable", the tail of tTestList is "abcd", xResults)

    sort tTestList in ascending text order

    testLog("Sort", "AscendingText", the head of tTestList is "abcd", xResults)
    testLog("Sort", "TextStable", the tail of tTestList is 2, xResults)
end handler

end module